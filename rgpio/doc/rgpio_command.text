2024-04-03  William A. Hudson

		rgpio Command Design
		--------------------

See also:  architecture.text

----------------------------------------------------------------------------
## Command
----------------------------------------------------------------------------

% rgpio --help
    Raspberry Pi GPIO utility
usage:  rgpio [main_options..]  feature  [options..]
  common:
    info         RPi Revision Information
    man          man pager
    fsel         Pin Function Select, by Gpio bit number
    header       Pin Function, by pin number on 40-pin header
  RPi4 and earlier:
    io           General Purpose IO pins
    clk          Clock generator
    iic          I2C Master
    pwm          PWM Pulse Width Modulator
    spi0         SPI0 Master
    timer        System Timer
    uspi         Universal SPI Master, Spi1, Spi2
    pads         Pads Control
    pud          Pin Pull-Up/Down - RPi3 and earlier
    pull         Pin Pull-Up/Down - RPi4 only
  RPi5 only:
    rio          Register IO
    rfunc        IO Function Select
    rpad         IO Pad control
  main options:
    --dev=m|g|f         device file type, m= /dev/mem (default),
                                          g= /dev/gpiomem, f= fake
    --rpi3              simulate RPi3 or earlier
    --rpi4              simulate RPi4
    --rpi5              simulate RPi5
    -n, --sim		simulate current platform (dry run)
    --help              show this usage
    -v, --verbose       verbose output, show if fake memory
    --debug             debug output
  (options with GNU= only)

----------------------------------------------------------------------------
## Simulate RPi Options
----------------------------------------------------------------------------

    The --rpi3 etc. options force simulation of the corresponding platform.
    Useful for exploring commands for other platforms.

    The --sim option simulates the current platform, essentially making
    like a dry run.

----------------------------------------------------------------------------
## Common Feature Behavior
----------------------------------------------------------------------------

RPi Platform:

    Command validity on the platform is checked by the Feature constructor,
    i.e. throw std:domain_error, not by the rgpio top-level program.  The
    resulting error message makes it clear it is a platform error.
    This helps demonstrate library behavior.

----------------------------------------------------------------------------
## Anti-Bugging
----------------------------------------------------------------------------

cout Manipulators:

    Using <<left with <<setw(8) will left-justify the value and fill on the
    right with the fill character.  If cout.fill('0') it will fill with
    zero, changing the apparent value.
    e.g.
	cout.fill('0');
	cout << "0x" <<hex <<left <<setw(8) << 0x33
    would produce  0x33000000

    Stream cout is global and cout.fill('0') is sticky.
    Manipulator <<setw() is not sticky.

    Manipulators <<left, <<right, <<hex, <<dec are sticky and easy to get
    an unexpected setting.  Especially when embedded in a subroutine.
    Anti-bugging could include:

    A) Always specify sticky manipulators in a new block.
	Especially if <<setw() is used.

    B) Restore default sticky manipulators when exiting a block.
	cout.fill(' ');
	cout <<dec <<right

using namespace std:

    Beware namespace clash with 'cout <<hex' io manipulator.
    A local variable declared 'int hex;' will be output instead.
    No compiler warning.  Same for other manipulators.
    Use 'cout <<std::hex' to be explicit when needed.

----------------------------------------------------------------------------
## Essential Process
----------------------------------------------------------------------------

    Rgpio is a cockpit command, essentially a big switch to configure and
    call the appropriate sub-command.

Essential process:
    + Configure rgRpiRev default SocEnum for simulation on non-RPi.
    + Construct rgAddrMap object.
    + Open device file.
    + Construct and Call the sub-command.

    For RPi4 and earlier (v0.22.0 2024_03_12), all commands had essentially
    the same default configuration for simulation when on non-RPi platform.

    With RPi5, the new commands are incompatible and require a different
    default configuration.

    When not on an RPi, we want all commands to run in the appropriate
    simulation mode for convenience.  Early experiments showed it was quite
    annoying to have to apply the correct --rpi5 simulation option.

Table lookup method:

    Now we need to lookup the command, and configure the appropriate default
    SocEnum before constructing rgAddrMap.

    The following code snippets illustrate the essential operations.  See
    rgpio.cpp for the actual code.

    // Define functions for calling each sub-command

	int	rf_io(   yOptLong *optx, rgAddrMap *amap ) {
	    y_io	rrx  ( optx, amap );
	    return  rrx.doit();
	};

	int	rf_rpad( yOptLong *optx, rgAddrMap *amap ) {
	    y_rpad	rrx  ( optx, amap );
	    return  rrx.doit();
	};

	...

    // Data needed for each sub-command
	class	entry_t {
	  public:
	    int		RpiNum;
	    string	CmdName;
	    int		(*Pfunc) ( yOptLong *optx, rgAddrMap *amap );
			    // pointer to function
	};
	    We need the RpiNum to configure rgRpiRev::Global.

    // Table entry for each sub-command
	entry_t		functab[] = {
	    { 0, "io",       &rf_io         },
	    { 5, "rpad",     &rf_rpad       },
	    ...
	    { -1, NULL,      NULL           }	// mark end of table
	};

    // Search table for sub-command
	entry_t		*entry = functab;	// first table entry
	for ( ;  entry->CmdName != NULL;  entry++ )
	{
	    if ( Opx.feature == entry->CmdName ) { break; }
	}
	...

    // Configure rgRpiRev default for RPi version
	if ( entry.RpiNum == 5 ) {
	    rgRpiRev::Global.SocEnum.defaultv( rgRpiRev::soc_BCM2712 );
	}
	else { leave default for RPi3 }

    // Construct address map
	rgAddrMap		Amx;
	Amx.config_FakeNoPi( 1 );		// when not on RPi
	Amx.config_Debug( Opx.debug );

    // Open dev file
	...
	Amx.open_dev_mem();

    // Call sub-command function
	retv = (entry->Pfunc) ( &Opx, &Amx );

    ...

Original method:  (rgpio v0.22.0 2024_03_12)

    The simple original method was a big "else if" chain for each command, e.g.
	...
	else if ( Opx.feature == "fsel"    ) {
	    y_fsel              fx  ( &Opx, &Amx );     // constructor
	    retv = fx.doit();
	}
	...

    This worked fine for RPi4 and earlier where all commands had the same
    default configuration.

