2017-05-10
		librgpio - Architecture
		-----------------------

Raspberry Pi C++ GPIO Library.

See also:  rgpio/doc/architecture.text

References:
-----------
BCM2835 ARM Peripherals
    Ref by RaspberryPi
    /home/var/ref/BCM2835-ARM-Peripherals.pdf
    https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf

    https://elinux.org/BCM2835_datasheet_errata


----------------------------------------------------------------------------
## Discussion
----------------------------------------------------------------------------

The Library provides a seperate class for each Feature (BCM2845 peripheral).

Possibly each class inherits from a common base class?

The idea is to represent each control register as a unit32_t value and
provide accessors to access each bit field.

Register read/write functions transfer the object register value to/from
the actual processor register.  Some functions may assist with requirements,
e.g. disabling the clock before changing its configuration.

Provide both direct unrestricted access, and methods for common safe operation.

All operations are essentially bit twiddleing.  The value add is:
1)  Abstraction that matches the BCM2835 ARM Peripherals description.
2)  Error checking.
3)  Object oriented interface.  Anti-bugging.

The typical #define bit twiddleing macros provide no error checking.
For configuration access, execution time is generally unimportant.

Using a C union with bit fields was considered, but the ordering and
packing of bit fields is compiler implementation dependent.  Portability
is not important, but having correctness based on experimentation is not
a good idea.  Thus use shift and mask methods instead.

The library classes are intended to be close to the hardware.  They are
NOT intended to hide the hardware or to provide a "future proof" interface
that will allow the hardware to evolve underneath.

rgpio Command-line Tool:
    The idea is to make a 'rgpio' command based on the library to provide
    similar register access and manipulation.

Pin/Bit
    The BCM IO space is accessed as 32-bit registers.  The idea is to stay
    close to this software access model, and thus we speak of bit positions.
    Sometimes "bit" and "pin" are used interchangebly, and usually mean "bit".
    Pin is often used to mean an IO pin of the chip, not a pin number.
    Pin could mean an connector pin number on the Raspberry Pi, but we do
    not provide that kind of pin mapping because different hardware may
    have different pin numbers.


----------------------------------------------------------------------------
## Error Handling
----------------------------------------------------------------------------

Exceptions:
    Exceptions are intended only for error handling.
    Library functions use exceptions as a way to get an error condition
    to a level where the program can report it thru the proper channels.

    Exceptions in libraries are NOT intended as a mechanism to test for
    a capability.  There are many possible exceptions, and they are not
    specific enough, and their meaning may change.

    We are using the C++ library <stdexcept> to classify and throw exceptions.

Error Reporting:
    Is the process of getting an error message to the user.
    Most programs will simply write it to stderr.

    A global class is used to report an error message, and to set a flag
    that an error has occured.  The flag can be later used to see if
    any error has occured, e.g. for setting program exit code.

Debug:
    Some classes will have a Debug attribute that can be set to trace
    function execution on stderr.  It is intended as a simple way for a
    user to see and verify some internal behavior.  The actual trace
    output may change.


----------------------------------------------------------------------------
## Validate on Raspberry Pi
----------------------------------------------------------------------------

    Device file /dev/mem exists on most Linux machines.
    Want to be sure we are on an RPi before diddling with it.  Fail safe!

See also:  lscpu(1) proc(5)

On my RaspberryPi-3 I get:

    % uname -a
    Linux raspberrypi 4.9.35-v7+ #1014 SMP Fri Jun 30 14:47:43 BST 2017 armv7l GNU/Linux

    % cat /proc/cpuinfo
    ...
  > Hardware        : BCM2835
  > Revision        : a22082
    Serial          : 000000009c13731b

    % lscpu
    Architecture:          armv7l
    Byte Order:            Little Endian
    CPU(s):                4
    On-line CPU(s) list:   0-3
    Thread(s) per core:    1
    Core(s) per socket:    4
    Socket(s):             1
    Model name:            ARMv7 Processor rev 4 (v7l)
    CPU max MHz:           1200.0000
    CPU min MHz:           600.0000

    The 'uname --nodename' can be most anything, e.g. 'raspberrypi', and
    is not useful here.

    The 'uname --machine' as "armv7l" could be helpful, but the processor
    architecture is not definitive of the hardware.

    The cpuinfo "Hardware : BCM2835" looks most meaningfull.  It also matches
    the "BCM2835 ARM Peripherals" documentation title.

    WiringPi decodes the cpuinfo "Revision : a22082" field.

  > Existance of /dev/gpiomem seems like a reasonable descriminator, but
    still is no guarantee.


----------------------------------------------------------------------------
## IO Address Map
----------------------------------------------------------------------------

Addresses:
    The peripheral addresses specified in the BCM document are bus addresses.
    (1.2.4 p.6)

    Addresses are byte addresses, and word (4-byte) aligned.
    Read/Write to periperal address are 32-bits (word size).
    Not sure what happens with a non-word aligned address, or a byte-size
    load/store.

    C address pointers could be:
 >  A) Word address
	uint32_t	*ptr;
	+ Alignment handled by compiler (i.e. is implied).
	+ Seems to be used by wiringPi and bcm2835 libraries.
	- BCM documentation address need to be divided by 4.

    B) Byte address
	uint8_t		*ptr;
	+ Matches BCM documentation.
	- Possible alignment error.
	-- Dereference pointer is a byte access, NOT what we want.

    Use "volatile uint32_t" for register address pointers to be specific
    about word size.  (Also used by wiringPi and bcm2835 libraries.)

Pointers and Addresses:
    Pointers are byte addresses (the underlying architecture address).

    Pointers are aligned according to the type of object they point to,
	e.g. a (uint32_t*) pointer is word aligned.

    The documentation is in terms of 32-bit registers, and presumably must
    be accessed as 32-bit words (not byte accessed).

    We use word pointers because we want to read/write 32-bit values
    (one word) to the peripheral registers.  Byte pointers (uint8_t*) would
    read/write only one byte to the register, assuming that byte size
    load/store is supported by the architecture.

    Pointer arithmetic is in terms of the size of object pointed to, the
    standard rules of C.
	e.g. incrementing a (uint32_t*) pointer adds 4 bytes to the pointer
	value.

	uint32_t*	p1;
	uint32_t*	p2 = p1 + 1;	// adds 4 bytes
	int		i = p2 - p1;	// difference is i=1 word

    Byte offsets in the BCM documentation must be converted into word
    offsets for (uint32_t*) pointers.
    Often offset enum and constants are defined as a byte offset divided
    by 4 to make this more explicit.

    I say all this, because confusion can happen when you print out pointer
    values (byte addresses), yet their difference is a word offset, not
    a byte offset as might be expected.  (Yes, it happend to me :-)

    Note:  C++ printing pointer values with 'cout << ptr' will show the
    value in hex with a leading "0x".  Quite convenient.


----------------------------------------------------------------------------
## Naming of code objects.
----------------------------------------------------------------------------

Enum:
    An enum name is a reserved word within its scope.
    Enumerators defined in a class are in the scope of that class.

    We choose:
    1) Put enums in a class to give the name context.
    2) Name enums with a lower case prefix to help group and make unique.
    [OA named their enums with prefix "oac".]
    If the enum should have limited scope, put it in the class it is used
    with.

Naming functions:
    Need a method to help user know wheather a whole register is acted on,
    or is it a bit field.

    read_REG()		Read whole register.
    read_FIELD_1()	Read a bit field.  The number is size of field.

    The numeric suffix, e.g. "_1", indicates both that it is a field access,
    and is the field width.  This makes the field width clear at the call
    point, and saves the person reading the code from having to look it up.
    The names are slightly more klunky, but worth it.
    This worked really well after trying it on the rgUniSpi class.

Function prefix name indicates over-all operation:
    addr_()         return address of register

    read_()         direct register/field read
    write_(V)       direct register/field write

    get_()          get object register/field value
    put_(V)         set object register/field value

    grab_()         copy register into object
    push_(V)        copy object into register

    Another name for "grab" is "pull", but I like the quirkyness of "grab".


----------------------------------------------------------------------------
## Feature Objects - common attributes.
----------------------------------------------------------------------------

Accessor functions get and put values into the object.
Action methods apply the object to the IO registers.

C++ would allow both get_() and put_() functions to have the same names,
since they are distinguished by different arguments.  This does not seem
very helpful to the user, as both functions still need to be declared.
Also a single function name seems awkward to have two different meanings.
Thus use two seperate names to make better clarity for the user.

All BCM2835 registers are 32-bits, with values stored in uint32_t.

Field values passed in accessor functions are also uint32_t, so no bits
are lost in the common conversion from int.
Possibly use int32_t, so negative values could be passed as some kind of
flag - e.g. -1 could mean set to default.

Register reserved fields:
    The BCM documentation identifies some hardware register bit fields as
    "Reserved, write zero, read as don't care".
    This is likely intended to help backward compatibility as new hardware
    features are added.

    Typical operation on configuration register bit-fields is to read the
    register, modify selected fields, and write the result back to the
    register.  This way all other fields remain unchanged.
    This same process should apply to reserved fields.
    The BCM advice to "write zero" would apply when specifying all
    register fields from scratch without starting from the current register
    values.

    This library provides low-level register access, and leaves it up to
    the user to "write zero" in reserved fields whenever the current register
    value is not used as the starting point.  This could be aided with a
    config_reset() or config_clear() function.

Object data:
    Feature objects could store a copy of register data.
    The idea is to provide a place to collect and organize the data when
    relationships between register values is important.  For example, the
    whole set of registers could be read at one point in time, and then
    individual accessor functions could extract and interpret data fields.

    Not all object methods would update this cached copy, especially those
    providing direct access with low execution overhead.

    Keep in mind that other parallel processes may update register values,
    and that accessing a group of registers is not atomic.

Exceptions:
    Throw an error object containing an error message.
    This would be most useful where continuing with some fallback condition
    is not a good idea.

Error handling:
    Some errors are better to proceed with a fallback condition, but want
    to alert the user that this has happend.  This is where calling global
    (or per-class, or per-object) error message function is good.  It would
    deliver a message on stderr, and set a flag that could be checked at
    program termination to set a non-zero exit code.

    I have used this method a lot in Perl programs, and found that detailed
    error tracking per object or per class is seldom needed.  Most valuable
    is a global error flag for reporting at program termination.
    Especially for utility type tools.
    Now a gui type tool that persists over many operations and needs to
    recover objects after an error would benifit from per-object tracking.

GpioBase address:
    Each Feature object can contain its own copy of the GpioBase address.
    The address allows the object to access the physical IO registers.
    A single process will generally have only one map of the GPIO address
    space, so all addresses will be the same.

    Methods to access a GpioBase address:
    [This is the user process space full address for each feature.]
 >  A) Copy of GpioBase address.
	+ Keep only what is actually used.
	+ No dependance on another object.  [Not true if the object knows
	    how to use rgAddrMap.]
	- No object to query further information.
    B) Reference to a common GpioBase object.
	+ Full access to the object.
	- A bit more indirection to get the actual register address.
	- Dependance on another object.
    C) Pointer to a global value.
	+ Can check for null before accessing.
	- Not sure how to get desired effect when GpioBase object is destroyed.

    Methods to know "BCM2835 ARM Peripherals" address:
    [This is the documented full register address, grouped together by
    feature.  It needs mapping to the user process full address.]
 >  A) Each feature object knows its BCM address.
	x.init_io( rgAddrMap )
	The feature knows how to use an rgAddrMap object.
	+ Nicely self contained.
	- Dependency on rgAddrMap object.
	+ Testing would use a mock rgAddrMap.
    B) User tells feature what BCM address to use.
        x.init_addr( bcm.get_mem_block( addr ) )
	+ Give user control.
	-- User has to know the correct address.
	- More complex use.
	+ May help testing.

  > Each feature object knows what its "BCM2835 ARM Peripherals" documented
    address is.  We want the feature object to request the appropriate
    address block from the rgAddrMap object.

    What happens when the address map is revoked?
    We generally don't need to create and destroy multiple GpioBase
    objects.  It is sufficient to create one and keep it for the life of
    the process.  Otherwise it would be nice if the Feature object could
    know if the address map has been destroyed, before accessing it and
    getting a address fault.

    The memory map can only be removed by munmap() system call, after which
    accesses will generate SIGSEGV. 

    ==> Assume the GpioBase address and memory map will persist for the
    life of the process.  This is a good enough assumption.

    Each Feature object knows the offset to its control registers from
    the GpioBase address.

Base Address Checking:
    The object can be constructed without setting the base address.
    A seperate init_addr( rgAddrMap ) function can then be applied.

    A problem is the object may not be completely initialized before
    the first register access.

    A) Each access checks initialization.
	+ Defers initialzation to sometime after construction.
	- Each access must do the check.  Overhead.
	- Or risk bad address, e.g. *(GpioBase+reg).
	+ May help in development.
	- Is more stuff to test.

  > B) Constructor does initialization with a given rgAddrMap.
	+ Now the object is guareanteed initialized.
	+ Helps the user and makes one less step.
	+ Can still provied uninit constructor for development.  How?
	- Constructor requires initialized rgAddrMap object.

    The main use of deferred initialzation would be to allow construction and
    partial use of feature objects before the address map is selected.
    e.g.  enum string conversion.

    Another use is to allow construction of Feature objects before the
    Address Map object is initialized.  This may help with the ordering of
    things.

    As development progresses, I find more complexity with deferred
    initialization and not much use for an unitialized feature object.

Offset Address Range Checking:
    Feature addresses should all fall within the feature memory block,
    which is generally one memory page in size.  Register access should not
    be outside this range.  Ways to ensure this:

    A) Accessor functions only accept enums that are guaranteed to be
	within the feature memory block.
	+ The accessor and enum is the guarantee, no overhead.
	- Must keep enum address range clean - good practice anyway.

    B) Accessor functions provide a range check.
	e.g.  require  ((offset && 0xfffff000) == 0)
	+ Provide extra coverage where needed.
	- Overhead on low latency functions.

    Some libraries use #define instead of enum, and thus are not type safe -
    any integer can be substituted.  We want to do better.


----------------------------------------------------------------------------
## Register Object
----------------------------------------------------------------------------

    The idea is to make a register object base class, that would represent
    only a single hardware register in a feature.
    It would have the register value and the actual address of the feature
    register, so it knows how to read/write the hardware register.

    Each feature object would have a public set of derived register objects,
    which would have the specific field accessor functions.
    Then each register would be accessed by register name.  e.g.

    rgSpi0		sx  ( Ax );	// the feature object constructed
    sx.CntlStat.grab();			// copy from hardware
    sx.CntlStat.put_RunActive_1( 1 );	// modify field
    sx.CntlStat.push();			// copy to hardware

    This has the nice advantage of clearly associating each field with the
    proper register, making it obvious which register should be grab() or
    push().

    Previously, having all field accessors as methods of the feature object
    was a higher abstraction in which the register/field association was
    hidden.  This was nice, but also a problem in knowing which register to
    push to update a field in the hardware.

    Normally each derived register class would be in its own source file,
    but this makes a flood of files which are not very useful stand-alone.
    It was decided to put all derived register classes in the same file as
    the feature, especially since they are so closely associated with the
    feature.

    A stand-alone derived register could be constructed, but there is the
    problem of initializing its address.  Possibly the feature object could
    have register constructor functions that would return an initialized
    object.  Better yet is to use the C++ copy constructor syntax to
    initialize the new register object with the feature register (example
    below).  This way the user does not have to deal with register addresses.

    Having register objects outside the feature object is like storing a
    register value, but with much more capability.  Stored register values
    can be used to alternately update a register configuration without
    having to modify field values each time.  e.g.:  Spi0 regA could have
    RunActive_1=1, and regB RunActive_1=0.  Then simply do regA.push()
    to enable transaction, and regB.push() to disable it.

    The register object idea was developed after feature classes rgClock,
    rgUniSpi, and rgSpi0 were implemented.  In these it became apparent the
    full register operations, while simple, were being re-implemented each
    time.  When there were only a couple registers in a feature this was not
    a problem, however more complex features were having 5 to 10 registers.
    It was decided to explore register objects in the next feature implemented,
    and retrofit older features after proving/refining the concept.

    Register Object data:
    {
	Value		32-bit register value
	Addr		address pointer to hardware register in process memory
    }

    Base Object Methods:
    {
	addr()		return address of hardware register

	read()		direct read  of hardware register
	write(V)	direct write of hardware register

	get()		get object register value
	put(V)		put value into object register

	grab()		copy hardware register into object
	push()		copy object into hardware register

	get_field(...)	Generic Field accessors (protected)
	put_field(...)

	init_addr(...)  private initialization used by feature constructor
    }

    A very nice benefit is the Generic Field accessors are defined only once
    in the base class, and they no longer need a pointer to the register
    value.  The register specific field accessors are now more easily made
    as inline calls to the generic accessor functions.

    A slight disadvantage is the register address is stored in each register
    object, taking slightly more space.

    The base object methods are all simple operations, and no-longer need
    register offset values from the feature base address.  These methods
    can all be inline, and thus as efficient (with compiler optimization) as
    direct access to the register object address and value.

    Most of these benefits could be had without a Register base class, but
    it seems to be turning out really well.

    The Generic Field accessors are intended only for use by derived registers.
    As such, they are protected because safety relies on proper arguments.

Derived register class names:

    The feature object has public register names (choose well).  e.g.  Spi0
	CntlStat
	ClkDiv
	...

    Name each derived class with the feature class name followed by the
    register name, separated with '_' underscore.  These classes derive
    from rgRegister and add specific field accessor functions, which would
    be named the same as before.
    e.g.
	rgSpi0_CntlStat			derived class
	    get_RunActive_1()
	    put_RunActive_1()
	    ...
	rgSpi0_ClkDiv
	    get_ClockDiv_16()
	    put_ClockDiv_16()
	...

Constructing registers inside the feature:

    A feature contains derived register objects specific to the feature as
    above.  When the feature object is constructed, the register addresses
    should be initialized using the base class init_addr() function.
    Thereafter the addresses need never change.  The name init_addr() was
    choosen to make this purpose clear, as opposed to put_addr().

    The init_addr() function is not part of the normal user interface.
    I explored making it protected and using friend declarations, but things
    became too convoluted.  It is much better to leave it public, and
    document that it is not part of the user interface.

Constructing registers outside the feature:  (user application)

    No special functions are needed, and the standard C++ initialization
    and assignment of register objects by copying of members can be used.

    rgSpi0_CntlStat	cntl_a;			// un-initialized
    rgSpi0_CntlStat	cntl_b = sx.CntlStat;	// initialization

    cntl_a = cntl_b;	// object assignment

    Here cntl_a is not initialized, and has a NULL address, which is not
    very useful.  The user must avoid this situation, i.e. always use the
    copy constructor from the register in the feature object.

    Now cntl_b is initialized by the copy constructor, and has the same
    address as the register in the feature object sx.  Both address and
    value are copied.

    Assignment of register objects copy both address and value.

    Each feature register is a different class, so the compiler will not
    allow cross assignment or cross initialization between different
    registers.  Thus the use of register objects should be quite safe.

    Register objects have only simple values (no allocation of memory) so
    there is no need to specify special initialization or assignment
    operations.
    The address could become invalid if the defining rgAddrMap object is
    destroyed, but that is a hazard throughout.

Generic Field accessors - Error Check

    The put_field() function can do a run-time error check of the value,
    and if greater than the mask, then likely something is wrong - the high
    order bits won't get applied to the register field.

    Initially the register base class just throws an exception with a
    generic "rgRegister::put_field():  value exceeds ..." message, which
    is not very specific as to what register field had the exception.
    Improvements might include:

    A) The derived register could contain a constant string identifying
    the register name.

    B) A #define wrapper could apply __FILE__ and __LINE__ to identify
    exactly where in the source code the error occured.

    C) The message could include the bit position as a number to identify
    the field.

    Note that many field values are constants, simply configuring the
    feature.  Once debugged these are not a problem.

    Run-time variable field values are more succeptable to mistakes.  The
    user should probably do his own run-time check with better error message.
    Or apply a mask in the function call to ignore bad values.  These make
    an exception less likely, and maybe less important to have a better
    diagnostic message.

    Possibly no exception should be thrown.  Simpler in the library, but
    provides little help to catch mistakes.


----------------------------------------------------------------------------
## Object Structure
----------------------------------------------------------------------------

    Trying to show relationships among objects and classes.
    Incomplete.  Class diagrams might help.

Object hierarchy:  (who "has" who)

    Object class
    ------------
    rgAddrMap		Address Map

    rgAltFuncName	Alternate Function Names

    rgFselPin		Function Select
	rgAddrMap
	rgFsel_enum		Function Select mode (enumeration)

    rgIoPin		IO Pin control
	rgAddrMap
	rgIoReg_enum		Register address offset

		    The more styalized features:
    rgClock		General Purpose Clocks
    rgUniSpi		Universal SPI Master
    rgSpi0		SPI0 Master
    ...
	rgAddrMap		object passed to each feature

		    Example with derived register objects
    rgSpi0		SPI0 Master
	rgAddrMap
	rgSpi0_CntlStat		derived register classes
	rgSpi0_ClkDiv
	rgSpi0_DmaLen
	rgSpi0_Lossi
	rgSpi0_DmaReq
	    rgRegister		    registers in each feature

----------------------------------------------------------------------------
## rgAddrMap Object - IO Register Memory Map
----------------------------------------------------------------------------

    Each Feature (Peripheral) has registers in a seperate 4Kbyte block.
    Thus multiple mmap() blocks are needed.

Possible class names:
    rgPMap
    rgPerMap
    rgPerpMap
    rgPeripMap
    rgMap
    rgRegBlock
    rgBlocks
    rgMemBlock
    rgMemPage
    rgIoMap
    gGpMap
    rGpMap
    rgpMap
    goMap
    gpMap
    rgRegMap
    rgMemMap

  > rgAddrMap
    rgGpClock
    rgSpi
    rgI2c
    rgUart
    rgGpio
    rgPads

There are multiple memory devices:
    1)  /dev/mem	full capability, need root capability
    2)  /dev/gpiomem	only GPIO pins, normal user
    3)  fake_mem	fake on non-RPi

Access mode:
    1)  read/write
    2)  read-only		for read-only intent

    Want simple, obvious ways to specify particular modes.
    Want to avoid user mistakes in device name.
    Want to allow testing.

Specifying memory device:
    A) Seperate functions for each device.
	+ User cannot get wrong device file name.
	- Function per device file.
    B) open_dev_file( "/dev/mem" )
	+ Very clear what file is opened.
	+ User can specify alternate files.
	- Rely on user not supplying a wrong name.
  > C) Do both.

Object data:
{
    pagemap[]

    int		Dev_fd;		// file descriptor
    
  ? int		mode;		// 0= unset, 1= /dev/mem, 2= /dev/gpiomem,
    					3= fake
    char	*ModeStr;	// user file string, NULL= unset,
				// "/dev/mem", "/dev/gpiomem", "fake_mem"

    int		Prot;		// mmap() prot field,
					default (PROT_READ|PROT_WRITE)

    bool	Debug;		// enable debug trace on stderr
}

Object methods:
    ();		constructor, uninitialized object, for fine config.

    (1);	constructor, full heuristics, ready to use.
    			Select and open dev memory, drop_capabilities.

    get_mem_block( paddr );	// normal request for a register block
			Does the mmap() call.
			paddr = peripheral address in BCM spec

			// set mode and open Dev_fd
    use_dev_mem();
    use_dev_gpiomem();
    use_fake_mem();
 ?  use_heuristic();		// apply heuristic to select dev to open

			// change access mode for next mmap()
    prot_readonly();		// access read-only
    prot_readwrite();		// access read-write

    drop_capabilities();

    close_mfd();		// to release resource, or to change mode


    Possibly defer open of mfd until first get_mem_block() call.

Note:  Must take extreem care to Not use /dev/mem on a non-RPi machine,
    since writing it will likely trash the machine.

Constructor:
    Providing a fully initialize object (Def_fd open, etc) seems nice, but
    is hard to provide the multiple modes.
    Putting a switch in the constructor seems klunky.

    Seems better to provide only a simple constructor, with methods
    to configure it.  This takes more user steps, but is more obvious.

    Maybe add a constructor to do full capability with /dev/mem.

    Maybe a constructor to take a dev file name.  This could help testing.


Heuristic to select mfd mode:
    Not sure I like the heuristic idea.  Benefit is getting partial function
    when user has no permission.  Disadvantage is you don't know what you got,
    and not much comentary.

    if ( not on RPi ) {
	Mode = "fake_mem"
    }
    else if ( not exist /dev/gpiomem ) {
	Mode = "fake_mem"
    }
    else if ( have CAP_DAC_OVERRIDE ) {
	Mode = "/dev/mem"
    }
    else {
	Mode = "/dev/gpiomem"
    }

    Once selected, report errors if cannot open.


----------------------------------------------------------------------------
## rgClock Object
----------------------------------------------------------------------------

See:  p.105-108  6.3 General Purpose GPIO Clocks

See:  https://pinout.xyz/pinout/gpclk

    The following clock sources are available:
    0     0 Hz     Ground
    1     19.2 MHz oscillator
    2     0 Hz     testdebug0
    3     0 Hz     testdebug1
    4     0 Hz     PLLA
    5     1000 MHz PLLC (changes with overclock settings)
    6     500 MHz  PLLD
    7     216 MHz  HDMI auxiliary
    8-15  0 Hz     Ground

Output frequency:
    Fout = Fsource / DIVI			with no MASH
    Fout = Fsource / (DIVI + (DIVF / 4096))	average with MASH

    [Note BCM doc error (DIVF / 1024), is wrong as DIVF is a 12-bit value.]


The basic operation cycle is:
    x.read_regs();		read IO registers into object

    x.set_Mash( 0 );		modify object config
    x.set_Source( 5 );
    ...
    x.write_regs();		safely update IO registers

    There are restrictions on when IO register fields may change in order to
    avoid glitches and potential lock-up of the clock generator.
    Generally, the clock must be disabled, and have have become not busy
    (BUSY=0) before changing any config.

Output format:  (rgpio)
    ctl[31:0] = 0xfabc0000   control register
    div[31:0] = 0xfabc0000   divider register

    Field           Value     English          R/W Register
    -----------     -----   ----------------   --- ---------
    Clock0.Mash_2   = 3     integer division   rw  ctl[10:9]
    Clock0.Flip_1   = 1     not inverted       rw  ctl[8]
    Clock0.Busy_1   = 1     running            r   ctl[7]
    Clock0.Enable_1 = 1     disabled           rw  ctl[4]
    Clock0.Source_4 = 15    oscillator         rw  ctl[3:0]
    Clock0.DivI_12  = 4095                     rw  div[23:12]
    Clock0.DivF_12  = 4095                     rw  div[11:0]


    The idea is to make the status display almost self-descriptive, to
    reduce the need to continually refer to the manual.

    This output formatting is put in the object to be close to the source.
    Possibly it could be made as a friend object, or derived object.

    Here the English notes seem essential for things like Mash and Source.

    The R/W flags help know if you can change it.
    The Register bit positions help relate to reference doc and 32-bit
    hex value.

    The fields were renamed with a numeric suffix indicating the field width,
    after great success trying it on the rgUniSpi class.

Object data:
{
    volatile unsigned	*GpioBase;	// IO base address

    uint32_t		ClkNum;		// Clock number {0,1,2}

    uint32_t		CtlReg;		// Control  register value
    uint32_t		DivReg;		// Divisior register value

    int			BusyCount;	// Number of read_Busy() calls in last
					//    wait_disable() or apply_regs().
}


Methods:

    init_addr( rgAddrMap )

    get_clock_num()		Get clock number

			Direct low-level access:
    addr_Ctl()			Address of register..
    addr_Div()

    read_Ctl()			Read register..
    read_Div()

    write_Ctl(V)		Write register, no safety check..
    write_Div(V)

    read_Busy_1()			Read-only selected bits..
    read_Enable_1()

			Direct control:  (modify register fields)
    enable()			Set Enable=1	set_Enable()
    disable()			Set Enable=0	clr_Enable()
    wait_disable()		Set Enable=0, wait for not Busy.

    wait_while_Busy()		Wait for not Busy.  Handle Enable=1

    kill_generator()		Kill the clock generator.  modify_Kill(V)?
					set_Kill(), clr_Kill()?

			Object state operations:
    grab_regs()			Read all regs into obj.
    grab_default_regs()		Init default values into obj.

    apply_regs()		Safe apply obj to registers - disable,
					wait for not Busy, write.

			Field accessors of object state:
  ? get_Kill_1()	put_Kill_1(V)
    get_Mash_2()	put_Mash_2(V)
    get_Flip_1()	put_Flip_1(V)
    get_Source_4()	put_Source_4(V)
    get_DivI_12()	put_DivI_12(V)
    get_DivF_12()	put_DivF_12(V)
    get_Enable_1()	put_Enable_1(V)
    get_Busy_1()		--

			Test/Debug accessors:
    get_CtlReg()
    get_DivReg()

    put_CtlReg(V)
    put_DivReg(V)


----------------------------------------------------------------------------
## rgIoPin Object
----------------------------------------------------------------------------

This is the GPIO pins and alternate function select.

See:  p.89-104  6. General Purpose I/O (GPIO)

Features include:
    Function select - In, Out, Alt0 .. Alt5
    Output Set
    Output Clear
    Input read level
    Event Detect Status
    Rising  Edge Detect Enable
    Falling Edge Detect Enable
    High Detect Enable
    Low  Detect Enable
    Async Rising  Edge Detect Enable
    Async Falling Edge Detect Enable
    Pin Pull-up/down  (is write-only?)

    There are 54 general-purpose I/O (GPIO) lines, but only the first 28 are
    available on the RPi3.  The compute module can access the first 45.
    Be aware that some may be used for features on the RPi board itself.

    Each register has a low word for bits 31..0, and a high word for
    bits 53..32.  We provide access to both.
    Possibly have a user configurable range check to catch access outside
    of desired bit range.

Partitioning:
    Decided to partition these features into possibly 3 classes:

  + rgIoPin	IO Pin class.
		    Mostly the PinLevel and Detect register operation.
		    Raw operation on the full set of GPIO registers as 32-bit
		    registers.

  + rgFselPin   Function Select class.
		    Detail operation on the Fsel registers.

  ? rgPads	For special operation of pad pull-up/down resistors.

    The PinLevel registers and Detect registers could be split into two
    classes, but they seem sufficiently related.
    It is really the methods of operation that suggest seperate classes.
    Too many classes is also not helpful.

    The sub-classes use a pointer to the rgIoPin object for register access.
    Inheritance from rgIoPin does not really seem appropriate(?).

The basic configuration cycle is:  (maybe not!)
    x.read_regs();		read IO registers into object

    x.set_Func( .. );		modify object config
    x.set_Redge_Den( .. );
    x.set_Fedge_Den( .. );
    x.set_High_Den( .. );
    x.set_Low_Den( .. );
    x.set_ARedge_Den( .. );
    x.set_AFedge_Den( .. );
    ...
    x.write_regs();		update IO registers

	But this is not Atomic.

    Decided to provide only direct hardware register modification for now.
    There does not seem to be much value in keeping register values in the
    object, and not worth the additional complexity.

Data read/write:
    The Read/Set/Clear of pin values is handled by giving direct access to
    the correspondig address.  User code then can read/write as necessary
    to provides the fastest access.

    Possibly also provide accessor functions to operate on a single pin.

Levels of access:
    1) Just provide the register address.  User does all bit twiddling.

    2) Accessor operations for similar registers - e.g. Function Select,
	Detect Enable, Detect Status.
	Operate on small groups of registers.
	Multiple pin operation, since each register is multiple pins.

    3) Single pin operation - modify only one pin of the register.
	Use a pin number instead of a word mask.

    4) Operate on full set of registers - i.e. read/write all registers
	from object data.

    These could mix-and-match, but be aware of both the pin state and object
    state.

Object Data Structure:

 >  Decided NOT to store any register values in the object.  (2018-05-25)
    Use only direct access to the hardware registers.
    There does not seem to be enough value in caching the register values
    in the object for the extra complexity.  Especially given the shared
    nature of the IO pin registers among multiple processes, it is even
    more important to make updates as close to atomic as possible.

    Most registers have one-bit per pin.
	unit32_t	EventStatus

    The Function Select registers have 3-bits per pin.
	Note only FselReg[0..3] are used on RPi.

 >  A) Use register layout directly.
	unit32_t	FselReg[0..5]
	+ Direct access to register values.
	- Must map user abstraction to these.

    B) Abstract into an array of pins.
	uint8_t		FselPin[0..27]
	- Must map into register values for read/write.
	+ Nice user abstraction.

    C) Store both forms.
	+ Conceptually nice.
	- Accessors must update both.

 >  D) Store one form, let the other be Virtual thru accessors.
	+ Probably safest.

    The mapping function needs to be well tested.
    It looks like the mapping can be algorithmic.
    Possibly Fsel is its own object, possibly inherited.

    It is useful to see pin mode with all pins layed out as a 32-bit register.
    Use one char for for each pin, encoded with the pin-mode.  This helps
    see what mask values are needed when doing direct read/write.
    e.g.
	.... iiii iiii iiii oooo 0001 1000 iiii
	    i    = input
	    o    = output
	    0..5 = Alt0 .. Alt5

    get_Fsel()		Return array FselPin[0..27] of mode values.

  x put_Fsel( uint8_t mode[0..27] )	Set mode on all pins.
		Not really useful, unless you read first and modify.

    set_FselMask( uint8_t mode, uint32_t mask )
	mode = the function select mode (3-bit) enum
	mask = one bit per pin, 1= active, 0= not changed
	This should be read-modify-write update.

    get_FselMask( uint8_t mode )	Return mask of pins with that mode.

  ? get_FselReg( reg_number )
  ? put_FselReg( reg_number )

    Mode values:
	1) The raw 3-bit value. { 00, 01, 04,05,06,07,03,02 }
	2) Abstracted Enum.	{ In, Out, Alt0, .. Alt5 }
	3) Character encoding.  { i, o, 0, 1, 2, 3, 4, 5 }

    enum rgFsel_enum {
	fselIN   = 'i',
	fselOUT  = 'o',
	fselAlt0 = '0',
	fselAlt5 = '5',
    }
	Naming these enum with char constants may help in per-bit display.
	Essentially allows using the char constant as the enum value.

    enum rgFsel_enum {
	f_IN   = 00,
	f_OUT  = 01,
	f_Alt0 = 04,
	f_Alt5 = 05,
    }
 >	Naming with raw 3-bit value helps putting the value in the control
	register.

Object register data as individual members or array:
 >  A) Data members named by register, e.g.
	EventStatus_w0
	ReadLevel_w0
	+ Better identification of registers, not indirect thru enum.
	+ Registers are NOT uniform in their properties.
	- More member names.
	- Access thru enum may be more complex.
	+ Best for individual register accessor functions.

    B) Data array indexed by register Enum, e.g.
	RegVal[0..]		// index by IoReg_enum
	+ Single array, less member names.
	+ Direct mapping access by enum.
	- Sparce arry when enum is the IO register offset.
	- Relies on enum too much.
	- Implies registers are uniform when they are not.

Multiple register update:  Not Atomic.

    Update is by read-modify-write, in order to preserve previous values
    when only some bits change.
    How atomic does this need to be?

    The Function Select registers are shared data.  Multiple independent
    programs each need to set the mode for their pins.  (We assume the pins
    are different in each seperate program.)
    Independently running programs are asynchronous.
    Therefore a synchronization problem exists if register update is not
    atomic.

    In general the synchronization problem cannot be avoided.  The user
    must provide synchronization.  This is OK, and expected.
    [Possibly use mmap() MAP_PRIVATE? - no.  Copy-on-write makes private
    copy and updates are not carried through to the underlying file.]

    Writing only the register modified helps.
    Making the read-modify-write window small helps.
    Thus it might be better to let a single library function call do the
    read-modify-write, instead of seperate calls.
    The set_FselMask() could do this, possibly even isolating to one of
    the 5 registers depending on which mask bits are used.

    I like letting such shared access be done by only a central user utility
    program, run directly by the user.  Then there is no shared resource
    between independent applications.

    Note the Event Dectect registers are shared over all bits, and must
    must be updated by read-modify-write.  Sharing different pins among
    processes seems problematic.

    Consider adding semmaphore capability to help solve synchronization
    problems.  For now, single function read-modify-write seems pretty
    good.

Register update methods:

 >  A) Use a bit mask.
	set_High_Den( mask )
	clr_High_Den( mask )
	+ Operate on all pins at once.
	+ Is close to the programming side.

    B) Use a bit number.  Per-pin update.
	set_High_Den_pin( pin )
	clr_High_Den_pin( pin )
	- Must repeat call for each pin to change.
	- Not as flexible.

    Class data could still be updated in passing.

    It is nice to have one function that reads everything at once, to get
    a snapshot in time.  Just not good to write that to registers, since it
    may have externally changed.

Register access function naming:
    Many config registers are read/write.  Reading all bits is fine.
	read_detect_Rising()

    Writing the register should change only the desired bits according to
    a mask, doing a read/modify/write.  Model as:

    A) Seperate set/clear functions.  1-argument
	set_detect_Rising( mask )
	clr_detect_Rising( mask )
	+ Mimic the set/clr PinLevel registers.
	- Takes two calls to set some bits and clear others.

 >  B) Single function with value and mask.  2-arguments
	put_detect_Rising( value, mask )
	+ One call to both set and clear bits.
	+ Fewer functions.
	- More arguments.

	Maybe name modify_*() to distinguish hardware register access from
	simple data structure access put_*().

Register access enums:  rgIoReg_enum
    Use enums for the register offset addresses.  The enum value is the
    offset value, which can work even with widely seperated values.

    The enums are defined in the class to provide context.  Thus the class
    name is required on the enum name e.g.
	rgIoPin::rgPinLevel_w0
    Seems a bit long, but very specific.

    Enum name strings are provided by a lookup table indexed by rgIoReg_enum.
    The enum values are close enough together to make this practical, and
    have one less mapping.
	static const char*  RegStr[];

    Use accessor functions for enum name string mapping.
	str_IoReg_enum( enum )
	find_IoReg_enum( str )

    String for an enum will throw an exception if the enum is invalid.  This
    is reasonable since the compiler checks the enum.

    Finding enum for a string will throw an exception if enum is not
    found.  In this case we generally have an unknown string and are trying
    to see what enum it represents, if any.

    Decided enum string names should be identical to the enum name, at least
    in the library.  This makes less mappings, and is close to the library
    code (i.e. can cut/paste names between code and external user interface).

    Generic functions can use an enum argument.
    Functions named by the register seem clearer in user code.
    Probably provide both.

find_IoReg_enum() methods for handling "string not found":
    A)  Return a special value, rgIoReg_INVALID.
	+ This is the traditional approach.
	- Requires another enum value.
	- User may not check return value for INVALID.
	- The INVALID enum then becomes a problem for other functions, which
	    then require an additional check.
	- The enum space is no longer uniform.

  > B)  Throw an exception.
	+ Is the C++ way.
	+ Use a local try/catch block if you want evasive action.
	+ Top level try/catch block covers case when you don't care.

Register pair naming:
    The Broadcom names are short, but a bit too cryptic (e.g. GPAFEN0).
    The suffix '0' and '1' is not that all obvious out of context.
    Using A/B seems a little better.
    The seperating underscore helps.

    A)  HighDetect0	bits 31..0
	HighDetect1	bits 53..32

    B)  HighDetect	bits 31..0
	HighDetect32	bits 53..32

    C)  HighDetectA	bits 31..0
	HighDetectB	bits 53..32

    D)  HighDetect_A	bits 31..0
	HighDetect_B	bits 53..32

    E)  HighDetect_0	bits 31..0
	HighDetect_1	bits 53..32

 >  F)  HighDetect_w0	bits 31..0
	HighDetect_w1	bits 53..32
	+ Give the 0/1 a little more meaning.

    G)  HighDetect	bits 31..0
	HighDetect_B	bits 53..32
	+ Nice for low bits, no suffix.
	- Is asymetric when both ranges are used.

    Possibly use uint64_t bit values and treat like one register.
	+ Nice abstraction.
	- Not very close to the hardware.
	- Longer words for bit twiddleing.
	- Implies operating on two registers.

    Possibly dual functions with a uint32_t mode and uint64_t mode.
    Dealing with 64-bit values, which must be decomposed into 32-bit words
    for IO register access, seems too complex.
    ==> Use only 32-bit words, with register pairs.

Accessor Register pair naming:
  > A) Use suffix _w0, _w1:
	read_PinLevel_w0()
	read_PinLevel_w1()
	set_PinLevel_w0( mask )
	set_PinLevel_w1( mask )
	+ Very clear naming.
	- More functions.
	+ Simple functions, easily inline.

    B) Optional argument for word number, defaulting to 0.
	read_PinLevel( 0 )
	read_PinLevel( 1 )
	set_PinLevel( mask )
	set_PinLevel( mask, 1 )
	+ Fewer functions.
	- Optional arguments are not very obvious.
	-- Very confusing with Value or Mask arguments.  Ugh!
	- More complex function, but can still inline.

PinLevel registers:
    The IO pin levels are accessed by 3 registers - read, set, and clear.
    The read register is read-only.  The set/clear registers are write-only.

    A generic modify_reg() read/modify/write function will not work for these
    individual registers.  It might be most useful to abstract this as a
    single PinLevel "virtual register", and not as 3 registers.  But this
    would loose closeness to the hardware.

    Direct PinLevel operations are:
	read_PinLevel_w0()
	set_PinLevel_w0( mask )
	clr_PinLevel_w0( mask )
    These names make operations clear on an abstract PinLevel register, and
    are one-to-one with physical registers.

    Thus "PinLevel" can be an abstraction for the collection of 3 registers.
    We want different names for the abstraction and the actual registers.
    Do NOT put an abstraction in the register enums (rgIoReg_enum), as that
    introduces a non-uniformity.

    PinLevel register enum names:
    A) old idea, initially implemented
      rgPinLevel_w0
      rgOutSet_w0
      rgOutClr_w0
	+ Names similar to the BCM documentation.
	- Not obvious these registers are related.
	- Not clear PinLevel is a read-only register.
 >> B) new, improves on BCM naming
      rgPinRead_w0
      rgPinSet_w0
      rgPinClr_w0
	+ Common prefix groups them together.
	+ More clear which are read and which are write.
	+ Not confused with abstration PinLevl.
	- Not match BCM naming.
    C) hybrid
      rgPinLevel_w0
      rgPinSet_w0
      rgPinClr_w0
	+ PinLevel matches the BCM name.
	- Not clear PinLevel is read-only.
    D) trying to incorporate BCM name in the name
      rgPinLevelRead_w0
      rgPinOutSet_w0
      rgPinOutClr_w0
	- A little longer.
    E) longer
      rgPinlevRead_w0
      rgPinlevSet_w0
      rgPinlevClr_w0

  > Address function names:  correlate with register enum names
	addr_PinRead_w0()
	addr_PinSet_w0()
	addr_PinClr_w0()

    Note that all the GPIO registers are "pins", and we are narrowing the
    meaning of "Pin" to just the pin level registers in this case.

PullUpDown registers:
    These should be abstracted also.
    Make a seperate class, maybe called rgPud or rgPads.

Function Select registers:
    Probably abstract to per-bit manipulation, as whole words is fairly
    complex and not that useful.

    Bit manipulation is provided in a seperate rgFselPin class.
    Whole register access is still provided here.

Generic Register access:
    Provides the same operations for all registers, but some may not be
    appropriate (e.g. write-only registers).

    The generic register methods do not need _w0 or _w1 word access because
    that is contained in the register enum.


Methods:
    (Need high/low register designation)

    read_all_regs()	read all IO registers into object
  x write_all_regs()	write object to IO registers - not recommended.

		read-modify-write update:  (updates object)
    put_FselMask( mode, mask )

    clr_EventStatus( mask )

    put_detect_Rising( value, mask )
    set_detect_Rising( mask )
    clr_detect_Rising( mask )

    set_detect_Falling( mask )
    clr_detect_Falling( mask )

    set_detect_High( mask )
    clr_detect_High( mask )

    set_detect_Low( mask )
    clr_detect_Low( mask )

    set_detect_AsyncRising( mask )
    clr_detect_AsyncRising( mask )

    set_detect_AsyncFalling( mask )
    clr_detect_AsyncFalling( mask )

    set_PullUpDown_mode( mode, mask )

		immediate write:  (no copy in object)
    set_PinLevel( mask )
    clr_PinLevel( mask )

		immediate read:  (also puts copy in object)
    read_FselMask( mode )
    read_EventStatus()
    read_detect_Rising()
    read_detect_Falling()
    ...
    read_PinLevel()		all pins

		object accessor:
    get_FselMask( mode )
    get_EventStatus()
    get_detect_Rising()
    get_detect_Falling()
    ...
    get_PinLevel()		all pins

		register address:
    addr_PinRead_w0()			addr_PinLevel_w0()
    addr_PinSet()
    addr_PinClear()
    addr_EventStatus()

		generic functions:  use register identifier enum R
    addr_reg( R )			address of register
    read_reg( R )			read register
 ?  get_reg( R )			get object value, no read
    modify_reg( R, mask, value )	modify register
    set_reg( R, mask )			set bits in register
    clr_reg( R, mask )			clear bits in register

    Argument order with mask before value for consistancy.  Maybe??

Object data:
    Evolve members to work with object methods.
    All uint32_t.
{
  - RegVal[0..]		// register value indexed by IoReg_enum
				Sparse array, easy mapping.  Not favored.

		Config registers:
    FselReg[0..5]

    DetRising_w0
    DetRising_w1

    DetFalling_w0
    DetFalling_w1

    DetHigh_w0
    DetHigh_w1

    DetLow_w0
    DetLow_w1

    DetAsyncRising_w0
    DetAsyncRising_w1

    DetAsyncFalling_w0
    DetAsyncFalling_w1

		Data registers:
    PinLevel_w0			(ReadLevel)
    PinLevel_w1
	Note the member is read/write, the register is read-only.

    EventStatus_w0
    EventStatus_w1
}

IO register enum name ideas:
enum IoReg_enum {		? IoPin_enum,  GpReg_enum
    detect_Rising      = 0x4c,
    detect_Rising32    = 0x50,
    detect_FallingA    = 0x58,
    detect_FallingB    = 0x5c,
    detect_High0       = 0x64,
    detect_High1       = 0x68,
    ...
    rgcEventStatus     = 0x..,
    rgcPinLevel        = 0x..,
    rgcDetectHigh0     = 0x64,
    rgcDetectAsyncFallingA

    rgPinLevel_w0      = 0x..,
    rgPinLevel_w1      = 0x..,

				FuncSel registers for low-level access only.
    rgFsel_r0          = 0x..,
    rgFsel_r1          = 0x..,
    rgFsel_r2          = 0x..,
    rgFsel_r5          = 0x..,

    rgFsel0            = 0x..,

}
    Enum names need to be distinct from object data names.
    Data names could be private.

----

Accessor method name ideas:

    set_Redge_Den( mask )
    clr_Redge_Den( mask )
    set_Fedge_Den( mask )
    clr_Fedge_Den( mask )
    set_High_Den( mask )
    set_Low_Den( mask )
    set_ARedge_Den( mask )
    set_AFedge_Den( mask )
    ...

    set_Den_Redge( mask )
    set_Den_Fedge( mask )
    set_Den_High( mask )
    set_Den_Low( mask )
    set_Den_ARedge( mask )
    set_Den_AFedge( mask )
    ...

    set_Den_Rising( mask )
    set_Den_Falling( mask )
    set_Den_High( mask )
    set_Den_Low( mask )
    set_Den_AsyncRising( mask )
    set_Den_AsyncRising( mask )
    ...

    set_det_Rising( mask )
    set_detect_Rising( mask )
    set_detect_AsyncRising( mask )

Long names with full words seem helpful.


----------------------------------------------------------------------------
## rgFselPin  Class
----------------------------------------------------------------------------
    Function Select register manipulation class.

    It seemed best to put the Fsel bit manipulation here, along with any
    register storage, and let the rgIoPin class focus on whole word register
    operations.

    It has a pointer to an rgIoPin object to do the actual register access.

Function Select registers:
    Modification of all Fsel pins at once is a bit risky.  An accident could
    affect all pins.  It also aggrevates the synchronization problem with
    other processes.  Thus bit level modification is more useful, and probably
    sufficient.

    Read and save of all Fsel0..Fsel5 registers might be useful.  They would
    be all read at one point in time, and then accessors could get single
    bit values as needed.
    An equivalent could be read all registers and return an array of Fsel
    pin values with no saving.

    Possibly use an Fsel object to hold and manipulate values.
    An Fsel class could be a good container for the various transformation
    methods, things like:  Bit number to register and field position.
    Mode enum translations.

Data members:
    *IoPinX		rgIoPin register object
    FselReg[0..5]	Function Select register values

Methods:
				save state:
    grab_Fsel()				read and save all Fsel0..Fsel5 reg
    get_Fsel_bit( N )			get saved Fsel mode for bit N
  x get_Fsel_array( &A )		get saved Fsel mode for all bits
				direct access (no save):
    read_Fsel_bit( N )			read mode
    modify_Fsel_bit( N, mode )		modify mode
  x read_Fsel_array( &A )		read all fsel bits

    Not sure the array access is that useful.  Probably better to let
    the user do his own loop.

    Decided direct access is best.  Therefore not saving Fsel register state
    in object.


----------------------------------------------------------------------------
## Object Summary
----------------------------------------------------------------------------
    Summary of object data and methods for each class.
    Not intended to be an exact declaration, see *.h files for that.
    Use as a catalog to track implementation.

    key:
	+ = implemented

class rgAddrMap		IO Address Memory Map
{
 +  int		Dev_fd;		device file descriptor
 +  bool	FakeMem;        1= using fake memory, 0= not

 +  char	*ModeStr;	user file string, NULL= unset,
				    "/dev/mem", "/dev/gpiomem", "fake_mem"

 +  std::map<>	BlkCache;	cache of mapped memory blocks

    int		ProtMmap;	mmap() prot field,
				    default (PROT_READ|PROT_WRITE)
		Or pass in get_mem_block()?

 +  bool	Debug;		enable debug trace on stderr

 +  uint32_t	FakeBlock[4096];	simulate address block
    uint32_t	PageMap[]		track mapped blocks

		Constructor:
 +  rgAddrMap()			Construct uninitialized object.

 +  bcm2rpi_addr( bcm_addr )	Convert BCM offset address to RPi.
 +  text_debug()		Get debug text.

 +  config_Debug( bool )
 +  config_FakeNoPi( bool )

 +  open_dev_file( file )	Open file for mmap().
			    User wrappers:
 +  open_dev_mem()		Open /dev/mem
 +  open_dev_gpiomem()		Open /dev/gpiomem
 +  open_fake_mem()		Open fake memory.

    prot_readonly()		? config_readonly()
    prot_readwrite()		? config_readwrite()

 +  close_dev()			Close the device file.
    is_dev_open()		Query.

 +  get_mem_block( bcm_addr )	Get peripheral memory block for BCM address.
    drop_capabilities()		Drop root access capability.
 +  is_fake_mem()		TRUE if using fake memory

 +  size_BlkCache()		Number of entries in page cache.
}


class rgIoPin		GPIO IO Pin control
{
 +  *GpioBase;		base address

		Config registers:
    FselReg[0..5]	function select registers

    DetRising_w0
    DetRising_w1

		Data registers:
    PinLevel_w0
    PinLevel_w1

    EventStatus_w0
    EventStatus_w1

		Enumerations:
  + rgFsel_enum		Function select values, 3-bit octal
  + rgIoReg_enum	Register address offset, word address

		Constructor:
  + rgIoPin()			construct empty object
  + rgIoPin( rgAddrMap )	construct and initialize

  + init_addr( rgAddrMap )	init base address
  + get_base_addr()		get  base address

		Generic register access:  R= rgIoReg_enum
  + addr_reg( R )			address of register
  + read_reg( R )			read register
  + modify_reg( R, mask, value )	modify register
    set_reg( R, mask )			set bits in register
    clr_reg( R, mask )			clear bits in register

		PinLevel register access:
  + addr_PinRead_w0()
  + addr_PinSet_w0()
  + addr_PinClr_w0()

  + read_PinLevel_w0()
  + set_PinLevel_w0( mask )
  + clr_PinLevel_w0( mask )

		Event Status register access:
  + read_EventStatus_w0()

		rgIoReg_enum string conversion:
  + str_IoReg_enum( R )			return cstring
  + find_IoReg_enum( cstring )		return enum

}


class rgFselPin		GPIO Pin Function Select class
{
 +  *IoPinX		rgIoPin register object

    FselReg[0..5]	Function Select register values

		Class Data:
  + ModeStr[]		Fsel mode string names, indexed by rgFsel_enum.

		Enumerations:
  + rgFsel_enum		Function select values, 3-bit octal

		Constructor:
  + rgFselPin( rgIoPin* )		construct and initialize

		Direct access:
  + read_Fsel_bit( N )			read, return rgFsel_enum
  + modify_Fsel_bit( N, mode )  	modify

  + fselreg_bit( N, &pos )		Register field position

		rgFsel_enum string conversion:
  + str_rgFsel_enum( mode )		return cstring
  + find_rgFsel_enum( cstring )		return enum

}

