2020-11-03
		Raspberry Pi Revisions
		----------------------

Identify RPi chip revision for peripheral feature behavior.

Raspberry Pi revision codes (2024-03-05)
    https://www.raspberrypi.com/documentation/computers/raspberry-pi.html

Raspberry Pi revision codes (2020-11-03)
    https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md

OTP register and bit definitions
    One-Time Programmable (OTP) inbuilt memory block
    https://www.raspberrypi.org/documentation/hardware/raspberrypi/otpbits.md

vcgencmd  documentation
    https://www.raspberrypi.org/documentation/raspbian/applications/vcgencmd.md

Peripheral Addresses
    https://www.raspberrypi.org/documentation/hardware/raspberrypi/peripheral_addresses.md

----------------------------------------------------------------------------
## Discussion - RPi Revision
----------------------------------------------------------------------------

    The Raspberry Pi SOC computers have evolved in a mostly compatible way.
    This makes it possible that only slight changes in the library are needed
    in order to cover all RPi revisions.

    Two types of changes occurred:

    a) Base address of peripherals.
	The peripheral feature remained the same, but the base address changed.
	0x20000000  RPi1
	0x3f000000  RPi2,3
	0xfe000000  RPi4

    b) Feature register configuration.
	In RPi4, more features were added, and some Gpio pin locations changed.
	Most features have the same operation.
	Pull up/down resistor method changed significantly.

    Changes that affect librgpio are pretty much strictly correlated with
    processor chip.

    PPPP  Processor chip ID
	0: BCM2835  RPi1, Zero
	1: BCM2836  RPi2
	2: BCM2837  RPi3, and later RPi2
	3: BCM2711  RPi4

    From bcm2835 library:  http://www.airspayce.com/mikem/bcm2835/
	#define BCM2835_PERI_BASE               0x20000000
	#define BCM2835_RPI2_PERI_BASE          0x3F000000
	#define BCM2835_RPI4_PERI_BASE          0xFE000000

Feature register switch mechanism:

 >  A) Processor chip ID
	+ Chip ID already exists.
	+ Very strong correlation to register function.
	- Every literal chip ID becomes too many items.
	- Some chips have exact same function.
	+ Easy to apply when new difference is discovered.
	+ Use the Raspberry Pi Revision Codes.
	- May have to add new chip ID if difference not represented by rev code.

    B) New abstract name, e.g. RPi3
	+ People probably recognize RPi3 better than BCM2837.
	-- New definition must be maintained and evolved.
	- Not clear what each name really means.
	- Is CM3 (compute module 3) the same as RPi3?

See also:
    rgAddrMap::bcm2rpi_addr()

Derivation Methods:  (in other places)

    Raspberry Pi:
	Base address from  #include <bcm_host.h>  in /opt/vc/include/
	bcm_host_get_peripheral_address()
	Seems like a video host library with lots of other stuff.
	No explanation of how it gets the base address.

	See "Revision" line in
	% cat /proc/cpuinfo
	Revision        : a22082

	% cat /sys/firmware/devicetree/base/model
	Raspberry Pi 3 Model B Rev 1.2

	Get revision code from OTP registers.
	% vcgencmd otp_dump
	...
	30:00a22082

    bcm2835 v1.68:  (library)
	#define BMC2835_RPI2_DT_FILENAME "/proc/device-tree/soc/ranges"
	Decodes  BMC2835_RPI2_DT_FILENAME  to find the base address.
	Uses one big mmap() of all peripheral address space.

    wiringPi:  (library)
	Hardwire the base addresses.
	#define GPIO_PERI_BASE_OLD      0x20000000
	#define GPIO_PERI_BASE_NEW      0x3F000000
	Use piBoardId() to decode the "Revision" line in "/proc/cpuinfo".

    pigpio:  (library)
	Read "/proc/cpuinfo" for "Revision" line.
	Decode processor ID to set base address.

Ideas

    Compile time switch:
	Makefile could set #define for base address.
	Makefile could set #define to alter code function.
	Lowest runtime overhead.

    Run time switch:
	This would allow the same compiled code to run on multiple revisions
	of RPi.  Automatically derived would be handy.
	Manual setting allows users to override as necessary.

    Note user program must also be aware of the RPi revision, since it
    will be operating the features.

    The Library is intended to be close to the actual hardware, NOT abstract
    missing or somewhat equivalent features.

    What to do when the Feature is missing?
    Probably throw an exception.
    Maybe do nothing, let it ride.

    Library code should take each feature change on a case-by-case basis.

    Maybe provide query functions for features that change, to help user
    code take appropriate action.

    Have a chip identification function so code can switch on processor chip.
    Maybe return an enum that identifies the processor.
    e.g.  soc_BCM2835

    Really the only feature change is to RPi4.  The others all use the same
    BCM2835 peripheral set.  This should help.

    Do NOT try to future proof the library!  The future cannot be predicted.
    Better to change the code when the next processor arrives.

    Non-RPi platform - want to be able to compile and test.
    Need a flag to indicate non-RPi.

    Testing:  Need ability to test all flavors of RPi (that matter).
    Perhaps a protected method to set the RPi revision.  Let test case
    derive a class for testing.

    Finding SOC revision:
    Try to decode the various sources.
    Want it to be fairly direct, and not depend on too much.
    Maybe have a method for user to tell library what chip to use.

    Separate base address determination from SOC revision used for
    functionality switch.  May want to explore possible RPi4 function on
    an RPi3 board.

    Cache the derived result, to avoid re-derivation overhead.

Exceptions:

    Derivation can be complex, and may fail.
    Should we throw exceptions in that case?
    Or maybe fall back to a default?

    I think exceptions should be avoided in this case.  Failure to derive is
    not really an error, and thus should not be an exception.
    Reserve exceptions for true errors.
    The derivation method itself may not be appropriate.
    We provide lots of ways for the user to provide the correct results, and
    we should let the user validate any result.  (2020-11-07)

    The idea is to help the user forge ahead, even if auto derivation fails.
    I know I would be happy to simply hardwire the configuration in that case.

    Maybe have a configuration flag to indicate whether an exception should
    be thrown on error.  That way user can configure behavior according to
    the application.
    [Not implemented, decide to only use exceptions.]

 >  Decide to throw exception on derivation failure, as it is much simpler.
    Failure to derive is a kind of error, especially when a critical thing
    like BaseAddr depends on it.  The error flag/message idea was explored on
    initial implementation, and did not seem worth the effort.  (2020-12-10)

 >  Modified slightly so non-RPi machine is not an error, below.  (2020-12-17)

Result Outcome of Derivation:

    Possible derivation outcomes are:

	a) Good result on an RPi, no errors.
	    Values are valid.

	b) No result, NOT on an RPi, no errors.
	    Values should flag not on RPi.

	c) Errors in reading files or unexpected file format.
	    Throw exceptions.

    Both a) and b) are valid results and should not throw exceptions.
    Only errors c) should throw exceptions.

    The idea is to allow a user program to fall back on fake memory,
    allowing the program to run on a non-RPi machine.  This is desired
    behavior for the 'rgpio' command.

Class Name:

    rgRPiRev	traditional "RPi" abbreviation

 >  rgRpiRev	cleaner camel-case

    rgRpi	too short, its all RPi
    rgRev	too short, rev of what?

    One thought is to leave the "RPi" string for text documentation, and thus
    use "Rpi" in these identifier names.

Configuration of class:  (concept ideas)

    Configure base address.      Can be undef.
    Configure function chip ID.  Can be undef.

    a) Default base address and chip ID set at compile time.
	#define RG_BASE_ADDRESS  0x3F000000
	#define RG_CHIP_ID       soc_BCM2837
	    Use enum name for chip ID.

	#define RG_RPI_REV_CODE	 0x00a22082
	    We really only need chip ID, but full rev code may be easier to get.

    b) User config at run time.
	Allow setting explicit value, or undef for auto derivation.
	rgAddrMap::set_BASE_ADDRESS( 0x3F000000 )
	rgRpiRev::set_RPi_rev_code(  0x00a22082 )
	Maybe flags to indicate user provided config vs derived.

	rgRpiRev::set_soc_chip_id(   rgRpiRev::soc_BCM2837 )
	More direct to set only function chip ID.

    c) Automatic derivation at run time.
	If not already set (i.e. marked Final).
	Derive on first use, cache result to avoid repeated derivation.
	Need flags to indicate undef value, and already derived state.

    d) Base address undef, implies not RPi and fake memory simulation.
	(i.e. could not derive)

    e) Chip ID undef, implies default RPi3.
	(i.e. could not derive)

    Provide all these methods, so user has control regardless of his situation.
    User takes responsibility with user override.

    Want base address and chip ID to be stored separately and independently
    configured.  It is intentional that they might not agree, to allow
    exploring register space.  They may also come from separate sources.
    They are related only when derived from RPi revision code.
    They have orthogonal uses.

    The base address must be correct, or bad things may happen.
    The chip ID is likely less critical, as registers are simply missing.

    Base address is really used in rgAddrMap, and should be stored there.
    Chip ID function should be in new rgRpiRev class.
    How should these two classes be related?

    These are really class methods, no object needed.

Usage Model:
    How it looks to user.

    Want to preserve the simple use case of define rgAddrMap object with no
    arguments.

	// rgRpiRev:: user config goes here
	...
	rgAddrMap		Amx;		// construct address map
	Amx.open_dev_mem();
	...
	rgClk			Cx( &Amx );	// construct peripheral feature

User Configuring:
    Configure the rgRpiRev class with user code, assuming rgRpiRev class
    has default values, none marked final.

    Set defaults, but let auto derivation change it:  e.g.
	rgRpiRev::BaseAddr.put( 0xfe000000 );
	rgRpiRev::SocEnum.put( rgRpiRev::soc_BCM2711 );

    Force to particular config:  (disable auto derivation)
	rgRpiRev::BaseAddr.put( 0xfe000000 );
	rgRpiRev::BaseAddr.mark_final();

	rgRpiRev::SocEnum.put( rgRpiRev::soc_BCM2711 );
	rgRpiRev::BaseAddr.mark_final();

    Force revision code, let BaseAddr and SocEnum derive from that.
	rgRpiRev::RevCode.put( 0x00a22082);
	rgRpiRev::RevCode.mark_final();

User validate results:
    At any time, before or after operation that triggers auto derivation.

	value = rgRpiRev::BaseAddr.get();
	flag  = rgRpiRev::BaseAddr.is_final();

	value = rgRpiRev::SocEnum.get();
	flag  = rgRpiRev::SocEnum.is_final();

	value = rgRpiRev::RevCode.get();
	flag  = rgRpiRev::RevCode.is_final();

Usage Accessing:
    Normal access within librgpio is to call the top-level accessors to get
    the actual value, which could trigger derivation as necessary.

    addr = rgRpiRev::get_BaseAddr();

    switch ( rgRpiRev::get_soc_enum() ) {
    case  soc_BCM2835:
    case  soc_BCM2836:
	...
	break;
    ...
    case  soc_BCM2711:
	...
	break;
    }

Class/Object methods:
    Idea is to provide configuration via static class members.  The same
    methods to derive the configuration could also be useful as object
    methods.

    The static configuration might never read the RPi revision code, if it
    was configured as final with no automatic derivation.  Thus it would be
    good to have an object available for explicitly reading the RPi revision
    information.  Essentially re-use the same methods for two purposes.

    class rgRpiRevCode {	// for class object
	rgRpiRev_Soc	SocEnum;	// chip id
	rgRpiRev_Word	BaseAddr;	// IO base address
	rgRpiRev_Code	RevCode;	// revision code
    };

    class rgRpiRev {		// for configuration
	static rgRpiRevCode	Config;
    };

    These two classes could be in the same file to help human understanding,
    as they are closely related, and reduce file clutter.

    It seems plausible that these two classes could be folded into one,
    where the class would have itself as a static member, but that is not
    allowed.  It probably results in some kind of circular issue.
    Actually IS allowed, since it is a static member of itself!

Auto derivation method:
    Read  /proc/cpuinfo  to get the Revision word, which can be cached
    as RevCode.  Then derive SocEnum, and then BaseAddr.
    A valid Revision word is never zero.
    Possibly use zero as a flag for non-RPi?

    Field accessors can return bit-fields from RevCode.

    Possibly decode binary file /proc/device-tree/soc/ranges to get
    BaseAddr as was done in the bcm2835 library.

Derivation Hierarchy:
    The three word values are derived in a natural hierarchy (arrow to source)
	BaseAddr -> SocEnum -> RevCode

    Need an indication that derivation failed.
    The BaseAddr and RevCode can be zero to indicated failure.
    But SocEnum is an enum, with no invalid value (to keep it uniform), so
    add a separate flag to it.

    Failure to derive:  The object should set both the Final and the Fail flag
    (or value) before calling the find() method of the object depended upon,
    so that if an exception is thrown the object will be in a state marked
    Final and Failed.  This prevents re-derivation of a failed condition.

    Note that an exception can occur only on derivation, where (Final = 0),
    and not on any subsequent calls to find().  The Failed condition serves
    as the status for subsequent calls.

Object Relationships:
    Have the 3 rgWord objects, and methods to derive each.

    A) Flat side-by-side, no cross references.
	RevCode
	SocEnum
	BaseAddr
	+ Simple relations.
	- Derivation functions must be at top level.
	- Derivation does things to the objects, which is not the best
		object design.

    B) Hierarchy - each has the object it depends on.
	BaseAddr
	    SocEnum
		RevCode
	+ Simple hierarchy
	+ Derivation functions can be in each object.
	- Chain to reach deeper objects:  rgRpiRev::BaseAddr.SocEnum.RevCode

 >  C) Parallel, but each references the object it depends on.
	RevCode
	    -> has no dependency
	SocEnum
	    -> RevCode
	BaseAddr
	    -> SocEnum
	+ Best of both.
	+ Parallel access.
	+ Derivation functions can be in each object.
	- More complex initialization.

----------------------------------------------------------------------------
## Class Design - RPi Revision
----------------------------------------------------------------------------

    There is one 32-bit word that holds the encoded revision information.
    Idea is to treat it somewhat like a hardware register, even though it
    is not.

Register Name:

    RpiRev		too similar to the Class name
    RpiRevision
    RpiRevCode
 >  RevCode		descriptive, RPi understood from context

Field Names:  (from Raspberry Pi revision codes)
    Field               Bits     RPi       Description
    ----------------    ----     --------  --------------------------
    OverVoltageDis_1	[31]     N         Overvoltage disallowed
    OtpWriteDis_1	[30]     O         OTP programming disallowed
    OtpReadDis_1	[29]     Q         OTP reading disallowed
    --			[28:26]  uuu       Unused
    WarrantyVoid_1	[25]     W         Warranty has been voided
    --			[24]     u         Unused
    NewStyle_1		[23]     F         new-style revision code
    MemSize_3		[22:20]  MMM       Memory size, encoded
    MfgNumber_4		[19:16]  CCCC      Manufacturer
    ChipNumber_4	[15:12]  PPPP      Processor chip ID number
    BoardType_8		[11:4]   TTTTTTTT  Type
    BoardRev_4		[3:0]    RRRR      Revision

Abbreviations appropriate for this context are:
	Rev   Revision
	Dis   Disallowed
	Otp   One Time Programmable memory
	Mfg   Manufacturer

Field Naming:
    Try to avoid single word names.
    Use the word 'Number', as 'Code' or 'Id' seem over glorified.

    MfgNumber_4		- Manufacturer number
	MfgNum_4
	MfgCode_4
	MfgId_4
	Manufacturer_4

    ChipNumber_4	- Processor chip ID number
	ChipCode_4
	ChipId_4
	Processor_4

SOC Enum type name:
 >  enum rgRpiRev::Soc_enum {...}	chosen name

    Want the enum embedded in a parent class to help clarify what it belongs
    to, even though the qualified name is much longer.

    Several of the Feature classes (e.g. rgClk) prefixed the enum type name
    with the class name (e.g. rgClk_enum), which made sense because it was
    enumerating the class objects.

    In this case we are enumerating one of several fields in the revision
    code, and not the main class.  Initial implementation tried the name
    rgRpiRev_enum, but found it misleading and awkward, especially if other
    fields become enumerated.

----------------------------------------------------------------------------
## rgWord  base class
----------------------------------------------------------------------------
    Idea is to cache a word value along with a status flag.
    The value is intended to be externally derived from other sources.
    The flag tracks whether derivation is final, and should not be repeated.
    Methods to access both value and flag.

    A derived class provides the lookup and caching mechanisms.
    OR that could be completely external.

rgWord {
  private:
    uint32_t		WordVal;	// 32-bit value
    bool		Final;

  public:
    uint32_t		get()              { return  WordVal };
    void		put( uint32_t v )  { WordVal = v };

    bool		is_final()         { return  Final };
    bool		mark_final()       { Final = 1 };
    bool		clear_final()      { Final = 0 };
}

    This class stores a word value that is derived from other sources,
    and a flag that indicates if the value is final.

    To hold an Soc_enum, must change the type.
    Oh-my!  It wants to be a Template?  Is only changing type of a member.
    But it may be simpler to duplicate, since it is all in-line.  e.g.

rgRpiRev_Soc {
    Soc_enum		WordVal;	// SOC enum value
    ...
}

    Possibilities for rgRpiRev_Soc class:
 >  A) Inherit from rgWord and replace (hide) get() and put().  Note in
	adding the FailDerive flag also needed to replace mark_final() and
	clear_final().  Initially did this.
    B) Make rgWord be a template, would benefit only the get() and put()
	functions.
    C) Define without inheritance.  Probably simpler overall.

Put WordVal and Final:  put() accessor  (2020-12-31)

    Should the basic accessors keep WordVal and Final purely orthogonal,
    or combine in a natural way?
    Initial use of put() for configuring the register suggests that setting
    both WordVal=v, and Final=1 would be more natural.

    A) Pure orthogonal, put() sets only WordVal.
	+ Is more typical.
	+ Decoupled is a simpler model.
	- User must must be more aware about the Final flag.
	- When intent is to configure a final value, must make two operations
	    put(v)
	    mark_final()
	- When only put(v) is applied, user may be surprised that find()
	    overrode it.  This may be a hard bug to find.

 >  B) put() sets Final=1 in addition.
	+ Natural when intent is to configure a final value.
	+ A put() operation will stick, since it marks it Final.
	+ Model as a cached word:
	    find() returns value, and derives it if necessary.
	    put(v) sets value, and find() will not change it.
	- More complex definition.
	+ Slightly better information hiding?
	+ Extra operation is needed to set a value that find() will override.
	    This is not typically very useful, and is OK to require
	    additional work from user.
	+ Primary user view is simplified to just find() and put(v).
	    Secondary is_final(), clear_final(), and get() are needed only
	    for special cases, and mark_final() could be eliminated.
	- Setting a default SocEnum value to be left unchanged if find()
	    failed, e.g. not on an RPi, is two operations.
		put(v)
		clear_final()
	+   But this also makes it more obvious that find() will override.
	- Possible confusion with other definitions of put().
	- Possibly leads to "belt and suspenders" behavior, where user
	    applies mark_final() anyway.  [Unless it is removed.]
	- Ordering of put() and clear_final() matters.

    C) Same as (B), but rename put()
 >	putf(v)      short and suggests something more than put().
	put_find(v)  put value that find() will return
	put_final(v)
	put_hard(v)
	put_soft(v)  put value, find() will override

    We want naming and behavior that conveys the correct idea to the reader.
    The person writing code probably needs to double-check definitions anyway.
    One writer, many readers.
    I like (B) best.  It abstracts the high-level cache concept instead of
    just a raw value and flag.
    Maybe rename to putf() as a hint of Final.

----------------------------------------------------------------------------
## rgRpiRev_Code  Register Class
----------------------------------------------------------------------------

rgRpiRev_Code : public rgWord {
  protected:	// put in rgWord class?
    uint32_t		get_field();
    void		put_field();

  public:	// derive value if not final
    void		grab();

  public:	// field access
    uint32_t		get_FIELD();
    void		put_FIELD( V );
    ...

    uint32_t		get_Processor_4();
    void		put_Processor_4( V );

    uint32_t		get_BoardType_8();
    void		put_BoardType_8( V );

    uint32_t		get_BoardRev_4();
    void		put_BoardRev_4( V );
}

Possibly derive from rgRegister:  (NOT used)
    This would reuse the get_FIELD() functions.

    Problem is rgRegister has too much capability that does not apply - i.e.
    an Addr member and accessors (although could just ignore them).

    Note removing an inherited function breaks the "is-a" relationship,
    which is not a good idea, and is not allowed by the compiler.  It really
    suggests re-structuring the chain of inheritance so things build up
    instead.

----------------------------------------------------------------------------
## rgRpiRev  Class - RPi Revision
----------------------------------------------------------------------------
    This is concept ideas only.  See the actual implementation code files.

rgRpiRev
{		// All members are static (i.e. class members)
  public:
    enum Soc_enum {
	soc_BCM2835 = 0,	// RPi1, Zero
	soc_BCM2836,		// RPi2
	soc_BCM2837,		// RPi3, and later RPi2
	soc_BCM2711		// RPi4
    };

  public:	// word registers for user configure or query
    static rgRpiRev_Soc		SocEnum;	// chip id
    static rgWord		BaseAddr;	// IO base address
    static rgRpiRev_Code	RevCode;	// revision code

  public:	// primary use with auto derivation
    get_soc_enum()	return processor chip name enum, if final, otherwise
			    derive it from RevCode

    get_BaseAddr()	return BaseAddr, if final, otherwise
			    derive it from SocEnum

    get_rpi_RevCode()	return RevCode, if non-null, otherwise
			    derive it from /proc/cpuinfo
}

    This example shows static objects of the word classes.  Similarly could
    have a single static object that contains the word objects.

    Maybe derivation functions should be in each derived word class?  But then
    how does it access the other word objects?  It cannot.  Thus derivation
    must be top level methods.

Essential function ideas:
-------------------------

// Grab RPi Revision code from external sources if not final.
//    This one could be in the derived rgWord class, since it does not use
//    any other word objects.
uint32_t
rgRpiRev_Code::grab()	// or rgRpiRev::get_rpi_RevCode()
{
    if ( ! is_final() ) {
	Read /proc/cpuinfo, find "Revision" line and get value.
	If it was found {
	    put( value );
	}
	else {
	    leave default value
	}
	mark_final();
	// a null value means undefined.  User must check.
    }
    return  get();
}

// Return RPi GPIO Base Address, and derive it if not set.
//     uses:  get_soc_enum()
volatile uint32_t
rgRpiRev::get_BaseAddr()
{
    Soc_enum			soc;
    volatile uint32_t		addr;

    if ( ! BaseAddr.is_final() ) {	// Derive it from SocEnum.
 >>	soc = get_soc_enum();

	switch ( soc ) {
	case  soc_BCM2835:
		addr = 0x20000000;
		break;
	case  soc_BCM2836:
	case  soc_BCM2837:
		addr = 0x3f000000;
		break;
	case  soc_BCM2711:
		addr = 0xfe000000;
		break;
	}
	BaseAddr.put( addr );
    }

    return  BaseAddr.get();
}

// Return RPi chip ID (soc enum), and derive it if not set.
//     uses:  RevCode.grab()
Soc_enum
rgRpiRev::get_soc_enum()
{
    Soc_enum			soc_code;

    if ( ! SocEnum.is_final() ) {
	// Derive it from revision code.

 >>	RevCode.grab();
	soc_code = RevCode.get_Processor_4();

	SocEnum.put( (Soc_enum) soc_code );	// cast to enum
	SocEnum.mark_final();
    }

    return  SocEnum.get();
}

Compile time configuration:  (NOT implemented)
---------------------------
Use #define words passed in from the Makefile.
The #define words should NOT be in the header file, because their intent is
to configure the library at compile time.  Thus they should be in the .cpp file.

rgRpiRev.h
    class rgRpiRevCode {	// for class object
	rgRpiRev_Soc	SocEnum;	// chip id
	rgRpiRev_Word	BaseAddr;	// IO base address
	rgRpiRev_Code	RevCode;	// revision code
    };

    class rgRpiRev {		// for configuration
	static rgRpiRevCode	Config;
    };

rgRpiRev.cpp
    // hardwired defaults

    rgRpiRev::Config = {	// default configuration
	{ 0, rgRpiRev::soc_BCM2837 },	// SocEnum  for Rpi3
	{ 0, 0x3f000000 },		// BaseAddr for Rpi3
	{ 0, 0x00000000 },		// RevCode  undef
    };

    // or using #define  passed in from the Makefile:

    #ifndef RG_CHIP_ID
	#define RG_CHIP_ID	soc_BCM2837
    #endif

    #ifndef RG_BASE_ADDRESS
	#define RG_BASE_ADDRESS	0x3F000000
    #endif

    #ifndef RG_RPI_REV_CODE
	#define RG_RPI_REV_CODE	0x00a22082
    #endif

    rgRpiRev::Config = {	// default configuration from #define
	{ 0, rgRpiRev::RG_CHIP_ID },	// SocEnum
	{ 0, RG_BASE_ADDRESS },		// BaseAddr
	{ 0, RG_RPI_REV_CODE },		// RevCode
    };

    Use similar #define macros for the Final flag values.

    Note the brace structure method of initialization does not seem to
    apply to this static class object, it is not allowed by the compiler.
    However, the static object is initialized by the constructors, where
    the same concept of #define can be applied.

Initialization could also be at run-time derivation in the get() accessor of
each word class.

Initialization could also be by copying from a default configuration object.


Static Words in rgRpiRev:  (NOT used)
-------------------------
    It might look like this:

class rgRpiRev
{
    static rgRpiRev_Soc		SocEnum;
    static rgRpiRev_Word	BaseAddr;
    static rgRpiRev_Code	RevCode;
};

rgRpiRev.cpp file:
    rgRpiRev_Soc	rgRpiRev::SocEnum  = {RG_SOC_ENUM,  RG_SOC_ENUM_FINAL};
    rgRpiRev_Word	rgRpiRev::BaseAddr = {RG_BASE_ADDR, RG_BASE_ADDR_FINAL};
    rgRpiRev_Code	rgRpiRev::RevCode  = {RG_REV_CODE,  RG_REV_CODE_FINAL};

I favor making the whole object static instead.


Idea for a derived RevCode value:  (NOT used)
---------------------------------
    The revision code has complex derivation from /proc/cpuinfo.  Want to
    identify that source vs simply assigned by the user.
    A) Maybe another rgRpiRev_Word storage word?
	The derivation of the main one would be a call to the other one.
    B) Maybe just add another flag?
	Derivation could be inside.
    Maybe is too complex, no real need separate the sources, just let it ride.

 >  Maybe let user construct a new RevCode object, and use it to ensure a
    derived value is obtained.  This seems simpler and more direct.

============================================================================
## Review  2024-03-05  Evolution for RPi5
============================================================================

Review code and doc with a view toward RPi5 extensions.

Initial assessment:
    The manpage seems a bit complex and not clear on essential principles
    of operation and how to use it.  The override seemed confusing.
    (Reading 3 years after I wrote it.)

    The find() register chain actually looked quite clean in the code.
    Consider making the 3 registers more similar with flags for both Final and
    Failed.

    RPi5 is a major change in register structure requiring new object classes.
    Consider ways for user code to switch between RPi4 and newer RPi5.

    Perhaps rename rgWord::put() to putf() or override() to be more clear
    that there are side effects.

    Find a simple clear concept of how it should work.

New Definition:  rgRpiRev class

    The rgRpiRev class has 3 registers capturing key values in a derivation
    chain.  (The 'V' arrow points toward source.)

    BaseAddr:  The IO space base address, where all peripheral devices
	    are located.
	    Used by the library for memory mapping IO registers.
	    Derived from SocEnum using a hardcoded lookup table.
    V

    SocEnum:  The SOC (processor chip) identification.
	    Used to switch both library and user code.
	    Derived from the corresponding RevCode field.
    V

    RevCode:  The revision code stored in One Time Programmable (OTP) memory
	    register.  This is the official Raspberry Pi hardware mechanism
	    encoding information about the platform.
	    Not used by the library, but available for user code.
	    Derived from /proc/cpuinfo.
    V

    /proc/cpuinfo:
	    The Linux OS file identifying the RevCode.
	    This file is recommended by Raspberry Pi documentation.

    These objects have no hardware register, but we call them "registers"
    to parallel other hardware registers in the library.

    Each register has the following private attributes:  (class rgWord)
	WordVal   The word value itself.
	Final     Flag value is cached, and will not be derived again.
	Failed    Flag that derivation failed or that WordVal is invalid.

    Each register has a find() caching accessor that will derive the value
    if it is not Final, otherwise simply return the WordVal.

    Override of the derivation chain is provided by override() accessors in
    each register.  These will insert the given value, set Final, and clear
    Failed.

    The purpose of Override, is to provide a mechanism for the user to
    supply correct values when the built-in derivation has failed or gotten
    the wrong answer.  i.e. Avoid the user having to hack the library code.
    The library peripheral Feature classes use only BaseAddr and SocEnum,
    not RevCode.

    The derivation of values is automatic as needed.  Caching prevents
    re-derivation, since they are not expected to change over the life
    of the program process.

    With no override, the 3 values will be consistent, based on the
    derivation chain, regardless of which value is accessed first.

    With override, it is possible for them to be inconsistent.  E.g.
    find BaseAddr first, thus finding consistent SocEnum and RevCode,
    then override SocEnum to something inconsistent.
    Don't do this, or accept the inconsistency.
    The library should not babysit the users overrides.

    It is intended that all Override be done with the rgRpiRev class
    before the first peripheral (Feature) class object is constructed.

Global Data:

    The library has a global object  rgRpiRev::Global  that is a static
    object of class rgRpiRev.
    It is used by library Feature classes to switch code for the different
    RPi platforms, and is intended for that use in user code.
    It is global (static) data so it can be accessed directly.

    The name is scoped inside the rgRpiRev class to clarify what it is, and
    to avoid name space pollution.

Real Address size:  BaseAddr

    On RPi5 the real IO space base address is 0x1f_0000_0000.

    Thus BaseAddr must change to uint64_t.
    Need to revisit rgAddrMap.

    With this change, all 3 registers have a different type for WordVal.
    Investigate the value of deriving from rgWord.

Simplify:  Maybe remove short-hand accessor functions:
    rgRpiRev::find_SocEnum()
    rgRpiRev::find_BaseAddr()

    They add abstraction complexity and documentation confusion.
    It was a nice idea, but is now becoming a wart.
    The corresponding register find() is sufficient.
    See below.

find() Exceptions:

    The find() functions (methods) are high-level operations intended to
    both derive a value and cache that value for later use.
    The return value should always be correct (to the limit of the derivation
    algorithms), and if not, throw an exception.
    This way the user code can call the function and use the value without
    any need for further inspection.

    The earlier implementation (tag v0.21.0, 2023 Feb 14) had a hybrid of
    exceptions for some errors, and a Failed flag along with the cached
    value for others.  Thus if find() returns a value, the Failed status
    must always be checked to see if it is valid.
    e.g. It could be that the exception was caught and ignored.

    [See Stroustrup p.193, 296, 315]
    The C++ Programming Language, Second Edition, C 1991

    The Failed flag could be handy where the exception is caught.
    It could also trigger further exceptions if find() is used again.
    Is the Failed flag necessary?  Is it overkill?  Is it babysitting?

Override method:

    The putf() methods in each register described above is the essential
    operation, but not so obvious from a high level.
    Thinking of a way to provide the common override situations.

    Perhaps an Override() method could set one or all 3 global registers.

    Override() would set the appropriate registers, set Final, clear Failed,
    and set a static flag to throw an exception if called a second time.

    Ensuring Override() is called only once helps catch problem of multiple
    overrides in different places with different values.
    Each register could have an Overrode flag.

    A)
    rgRpiRev::Override( uint32_t )		// BaseAddr
    rgRpiRev::Override( Soc_enum )		// SocEnum
    rgRpiRev::Override( uint32_t, Soc_enum )	// BaseAddr and SocEnum
    rgRpiRev::Override( uint32_t, Soc_enum, uint32_t )

    B)
    rgRpiRev::Override( Soc_enum )		// SocEnum
    rgRpiRev::Override( Soc_enum, uint32_t )	// SocEnum and BaseAddr
    rgRpiRev::Override( Soc_enum, uint32_t, uint32_t )	// and RevCode

	The list of 3 arguments is not clear which is which.

    C)
    Possibly Override() could also force derivation of down stream registers.
    This would help provide consistency, and help avoid possible exceptions
    later.

    rgRpiRev::Override_Base( uint32_t )		// BaseAddr
    rgRpiRev::Override_Soc(  Soc_enum )		// SocEnum => BaseAddr
    rgRpiRev::Override_Code( uint32_t )		// RevCode => SocEnum, BaseAddr

    rgRpiRev::Override_Soc_Base( Soc_enum, uint32_t )	// SocEnum and BaseAddr
	These are the two critical ones.

	The idea here is to make simple overrides clear.  More complex things
	can be done with the individual register putf() methods.

	If you know enough to override the BaseAddr, you might as well
	override the SocEnum to match.

    D)  Possibly each register could have an Override().  Trickier to derive
    down stream registers, but the linkage could be made.

 >  E)  Maybe just clean up the individual register overrides and use that.
    Any override is really the user knowing better than the built-in
    derivation.  Minimal typing (of code) is NOT needed.  Make the resulting
    user code be as clear as practical.  Accept possible inconsistency.
    If BaseAddr is overridden, then SocEnum should also be overridden.
    The library should not babysit the users overrides.

Consequence of wrong values:

    Assuming the others are correct, possible consequences of a single
    wrong register value are:

    BaseAddr:  Is critical.  A wrong address means some unexpected page
	is being read or worse written.

    SocEnum:  Wrong peripheral objects would be operated.  The accessed
	addresses could still be far off, since the peripheral address
	offset can be very large.

    RevCode:  Not used by the library (so far).  User code would be mislead,
	but library addresses and SocEnum code behavior would be correct.

Rename:

    Rename static object member 'Config' to 'Global'.  To indicate that
    this is the globally accessible revision information.

    Rename the register rgWord::put() method to override(), to express
    the intent and side effects.  Maybe still have a primitive put() with
    no side effects.

Override in user code:

    See what direct register override might look like with new names.
    Can be applied in any order.  No other derivation is initiated.

	rgRpiRev::Global.RevCode.override( 0xfec03111 );	// RPi4B
	rgRpiRev::Global.SocEnum.override( rgRpiRev::soc_BCM2711 );
	rgRpiRev::Global.BaseAddr.override( 0xfe000000 );

    Just RevCode, let others derive from that.

	rgRpiRev::Global.RevCode.override( 0xfec03111 );	// RPi4B

    Just SocEnum, let BaseAddr derive from that.  RevCode could derive
    later and be inconsistent, which is acceptable.

	rgRpiRev::Global.SocEnum.override( rgRpiRev::soc_BCM2711 );

    Both SocEnum and BaseAddr.  Accept possible inconsistent RevCode.

	rgRpiRev::Global.SocEnum.override( rgRpiRev::soc_BCM2711 );
	rgRpiRev::Global.BaseAddr.override( 0xfe000000 );

 >  It is up to the user to put overrides together in a good place early in
    the program.

 >  The long structured names is fine, and adds clarity.
    Runtime efficiency is not critical.

    Possibly add a set of short-hand override accessors would parallel the
    corresponding set of find accessors:
    e.g.
	rgRpiRev::override_RevCode( 0xfec03111 );
	rgRpiRev::override_SocEnum( rgRpiRev::soc_BCM2711 );
	rgRpiRev::override_BaseAddr( 0xfe000000 );

	rgRpiRev::find_RevCode()	- not implemented
	rgRpiRev::find_SocEnum()
	rgRpiRev::find_BaseAddr()

    The abstraction is somewhat comforting if it was the only thing
    that is used.  But the real work is in the registers, and especially
    the RevCode register is used for field extraction.
    And the short-hand find_() accessors are essentially replaced by the new
    platform test functions (e.g. rgRpiRev::isRPi5() see below).
    The additional abstraction confusion is not worth it.
 >  Decide against short-hand override accessors.

Efficiency and find():

    Operations that are done rarely in a process lifetime typically do not
    need to be super efficient, and we are happy to trade a little more
    runtime for correctness.

    The SocEnum value can be used to switch code when the peripheral register
    structure differs by RPi platform.
    It would be great if the cached find() function were very efficient and
    could be used directly even in an inner loop.  e.g. If it could be
    inline code that simply returns the cached value.

    Unfortunately it is likely a real function call that must both test the
    Final flag to see if derivation is needed, and test the Failed flag
    to be sure it is valid (or else throw an exception).
    Probably not so desirable in an inner loop.

    One solution is to call and save the find() result in a local variable
    outside the loop, and test the variable in the inner loop.

Code switch on RPi platform:

    So far, the processor chip ID name (i.e. SocEnum) has strong correlation
    with the different RPi peripheral register structures.
    Thus the SocEnum value can be used to switch code blocks.

    The main idea is to get the SocEnum by calling:

	rgRpiRev::Soc_enum	soc = rgRpiRev::find_SocEnum();
	rgRpiRev::Soc_enum	soc = rgRpiRev::Global.SocEnum.find();

    Then switch code blocks.

    A) if-then-else

	if      ( soc == rgRpiRev::soc_BCM2835 ) {
	    // do RPi1
	}
	else if ( (soc == rgRpiRev::soc_BCM2836) ||
		  (soc == rgRpiRev::soc_BCM2837) ) {
	    // do RPi3, RPi2
	}
	else if ( soc == rgRpiRev::soc_BCM2711 ) {
	    // do RPi4
	}
	else if ( soc == rgRpiRev::soc_BCM2712 ) {
	    // do RPi5
	}

    B) switch statement

	switch ( rgRpiRev::find_SocEnum() ) {
	  case  rgRpiRev::soc_BCM2835:
	  case  rgRpiRev::soc_BCM2836:
	  case  rgRpiRev::soc_BCM2837:
	    // do RPi3, RPi2, RPi1
	    break;
	  case  rgRpiRev::soc_BCM2711:
	    // do RPi4
	    break;
	  case  rgRpiRev::soc_BCM2712:
	    // do RPi5
	    break;
	}

	The switch statement allows cases to fall thru.
	If the switch has no "default:", the compiler checks that all enums are
	represented, which helps catch situations where a new enum is added.

    The two switch blocks can be completely equivalent.

 >  Note the slightly longer (more typing) find function would also be
    acceptable here.  Saving only 7 characters is not worth the complexity
    of another abstraction.

    Note the soc_BCM names do not mean much to users who are more familiar
    with the RPi1 .. RPi5 sequential model numbers.  i.e. Need comments
    to make that association.

    See "## Platform test functions" below for another alternative.

User Interface Evolution:

    Thinking about library evolution and the user interface.
    Generally want widely used interfaces to be quite stable so a newer
    library version can be adopted in an old program with minimal, or no,
    code changes.  e.g. Using only the old features on old platforms.

    Names should be chosen carefully.  Although a name change is a much
    easier edit than a functionality change.

    Future proofing should be avoided.  The future cannot be predicted.
    The past is known, and does not change.
    Good design greatly aids future evolution.

    The platform test functions, e.g. isRPi5(), is one area:
    It is likely widely used.
    It should have a clean, well understood definition.
    It should neatly encapsulate the past in accessor functions with an
    interface that need not change.

----------------------------------------------------------------------------
## Refactor  rgRpiRev  class structure
----------------------------------------------------------------------------

    Now that BaseAddr is 64-bits, all 3 registers have a different type for
    the word value and need different access functions.  Thus having a
    common base class for the word value is not helpful.

    The derivation flags are common, so it might make sense to have a base
    class for them.

    We want all 3 registers to work similarly and have the same methods
    even though the word value types are different.  i.e. We want them to
    look polymorphic, but don't actually have to be polymorphic.

Flag Final:
    Word value is final, no further derivation should be attempted.

    Final	1= no further derivation, 0= not

Flag Unknown:
    Word value is unknown, as in not yet derived, or because of failed
    derivation.

    Unknown	1= unknown, 0= known good value

    Previously this condition was encoded as zero in the word value
    for RevCode and BaseAddr, while SocEnum had a FailDerive flag.
    RevCode could never really be zero.
    BaseAddr could possibly be zero, but has not been so far.
    It seems best to add an Unknown flag for all 3 registers.

Class rgWord:
    Can pretty much remain the same, but pull out the Final flag.
    Is a base class for only RevCode.

New class rgFlag:
    Can hold the flags and accessor functions, common to all 3 registers.

Class rgRpiRev_Code:
    Mostly unchanged, except now derive from both rgWord and rgFlag.

Class outlines:
    Here we outline the essential attributes from a user perspective.
    Additional methods should be provided to aid testing.
    Especially note the type differences in find() and override().

    Successful find() sets:  Final=1, Unknown=0
    Failed     find() sets:  Final=1, Unknown=1
    User   override() sets:  Final=1, Unknown=0

class rgFlag {
  protected:
    bool		Final;		// 1= no further derivation, 0= not
    bool		Unknown;	// 1= unknown, 0= known good value
  public:
    bool		is_final()	{ return  Final; }
    bool		is_unknown()	{ return  Unknown; }
};

class rgRpiRev::rgRpiRev_Code : public rgFlag, public rgWord {
  private:
    ...
  public:
    uint32_t		find();
    void		override( uint32_t v );
};

class rgRpiRev::rgRpiRev_Soc : public rgFlag {
  private:
    Soc_enum		SocVal;
    rgRpiRev_Code	*RevCode_ptr;
  public:
    Soc_enum		find();
    void		override( Soc_enum v );
};

class rgRpiRev::rgRpiRev_Base : public rgFlag {
  private:
    uint64_t		BaseVal;
    rgRpiRev_Soc	*SocEnum_ptr;
  public:
    uint64_t		find();
    void		override( uint64_t v );
};

----------------------------------------------------------------------------
## Platform test functions:  isRPi5(), ...
----------------------------------------------------------------------------

    The idea is to have a set of global (static) flags in class rgRpiRev
    that indicate the current platform.  Then the flags can be tested
    for TRUE to select code blocks, and avoid the Soc_enum comparison.
    The flags could be named by the generic names RPi5, RPi4, RPi3, etc.

    If the flag is TRUE, then that is the running platform, else the
    platform is unknown.  Unknown is critical here, because future
    extension may add new platforms, e.g. RPi6.
    Knowing that it is not RPi5 does not imply it must be RPi4 thru RPi1.

    It might look like this:

	class rgRpiRev {
	  private:
	    static int		IsRPi5 = 0;
	    static int		IsRPi4 = 0;
	    static int		IsRPi3 = 0;
	    ...
	    static int		IsRPi1 = 0;

	  public:
	    void		init_isRPi();	// initialize platform flags

	    static int		isRPi5()	{ IsRPi5; }
	    ...
	    static int		isRPi1()	{ IsRPi1; }

	    static int		isRPi4321()	{ IsRPi4 || IsRPi3 || IsRPi2 ||
						  IsRPi1; }
	}

	void rgRpiRev::init_isRPi()
	{
	    IsRPi1 = 0;
	    IsRPi2 = 0;
	    IsRPi3 = 0;
	    IsRPi4 = 0;
	    IsRPi5 = 0;

	    switch ( rgRpiRev::find_SocEnum() ) {	// may throw
	      case  rgRpiRev::soc_BCM2835:
		IsRPi1 = 1;  break;
	      case  rgRpiRev::soc_BCM2836:
		IsRPi2 = 1;  break;
	      case  rgRpiRev::soc_BCM2837:
		IsRPi3 = 1;  break;
	      case  rgRpiRev::soc_BCM2711:
		IsRPi4 = 1;  break;
	      case  rgRpiRev::soc_BCM2712:
		IsRPi5 = 1;  break;
	    }
	}

    The isRPi5() methods are accessor functions providing read-only access
    to the flags.  They should have no overhead with compiler in-line.

    The init_isRPi() method is called by the user to initialize the flags
    before any calls to isRPi5() functions are made.

    Initialization of a static object could be done by the object
    constructor, and would occur before any statement of the main program
    is executed (I think).  This would be handy to avoid the need for
    the user to call init_isRPi().  A disadvantage is it would also run the
    rather complex process of reading  /proc/cpuinfo  to derive SocEnum,
    possibly throwing exceptions.  It would also prevent user override of the
    derivation process.  Thus probably not initialized by constructor.

    Static global data for these flags fits their use quite well:  They
    are set once, and can be accessed anywhere in the program without
    passing around some kind of access handle.

    Top level accessor functions are essential here, as they allow the
    underlying implementation to evolve if necessary.  They also have
    access to RevCode or any future things needed to determine platform.
    And they provide a simple encapsulation of the past, avoiding user
    code changes.

    Example use:

	rgRpiRev::init_isRPi();
	rgRpiRev::initialize_isRPi();	// clearer name

	if ( rgRpiRev::isRPi5() ) {
	    ...
	}
	else if ( rgRpiRev::isRPi4321() ) {
	    ...
	}

    This seems pretty good and straight forward.  It helps to clarify
    code switch on a more recognizable name than the SocEnum.

Global object:  (user interface)

    The flags as defined here are global (static).  Thus a private copy
    cannot be created for testing/exploring as can be done with the
    Global object member.  This is less critical for now.  The accessor
    functions allow evolution of the underlying code.

    User interface:  (assuming appropriate differences in implementation)

 >  A)  rgRpiRev::isRPi5()

	++ Top-level, hides more implementation.
	+ Shorter, helping use in logical expressions.
	- Less obvious it is global (static).

    B)  rgRpiRev::Global.isRPi5()

	-- Showing more implementation.
	+ Obvious it is global.
	+ Uses Global somewhat similar to the override() methods.

    These are widely used, whereas the Override methods are not.  Thus the
    user interface is more critical.

    Implementation hiding is more useful for future evolution.  Favor top-level
    accessors for this.

Future name evolution:

    Expect new generations of RPi to continue and have unexpected changes.
    The existing RPi versions are well identified by the isRPi5() name style,
    and can remain unchanged.

    New platforms may need other information from RevCode to implement a
    code switch.  e.g. The same SOC may get a new IO chip and new register
    arrangement.

 >  New platform names could be in a different style or have a complete
    different derivation, and old names and function could remain the same.
    This is not possible with the old SocEnum comparison method.

    Possible Names:
	rgRpiRev::isRpi5()

 >	rgRpiRev::isRPi5()
	rgRpiRev::is_RPi5()

	rgRpiRev::isRPi_5()
	rgRpiRev::is_RPi_5()

 >	rgRpiRev::isRPi321()
	rgRpiRev::isRPi_321()

	The prefix 'isRPi' groups them together, i.e. in a search pattern.
	The 'is_' helps readability some.
	The 'Rpi5' may avoid the common use of RPi5 (good or bad?).

	I feel like the dense version (no underscores) is best.  (2024-03-13)

    Possibly name by the IO chip name, e.g. isRP1()?  This seems like too much
    future-proofing of names.

Separate Class:

    The platform test functions could be implemented as a separate class
    or sub-class.
    It would probably be private.
    Not really intended for the user.
    May help testing.
 >  Seems like a lot of complexity for not much benefit.

