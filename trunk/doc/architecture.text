2017-05-10
		rgpio - Architecture
		---------------------

Raspberry Pi GPIO Tool and Library

References:
-----------
BCM2835 ARM Peripherals
    Ref by RaspberryPi
    /home/var/ref/BCM2835-ARM-Peripherals.pdf
    https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf


----------------------------------------------------------------------------
## Discussion
----------------------------------------------------------------------------

The Library provides a seperate class for each Feature (BCM2845 peripheral).

Possibly each class inherits from a common base class?

The idea is to represent each control register as a unit32_t value and
provide accessors to access each bit field.

Register read/write functions transfer the object register value to/from
the actual processor register.  Some functions may assist with requirements,
e.g. disabling the clock before changing its configuration.

Provide both direct unrestricted access, and methods for common safe operation.

All operations are essentially bit twiddleing.  The value add is:
1)  Abstraction that matches the BCM2835 ARM Peripherals description.
2)  Error checking.
3)  Object oriented interface.  Anti-bugging.

The typical #define bit twiddleing macros provide no error checking.
For configuration access, execution time is generally unimportant.

Using a C union with bit fields was considered, but the ordering and
packing of bit fields is compiler implementation dependent.  Portability
is not important, but having correctness based on experimentation is not
a good idea.  Thus use shift and mask methods instead.

The library classes are intended to be close to the hardware.  They are
NOT intended to hide the hardware or to provide a "future proof" interface
that will allow the hardware to evolve underneath.

Note the utility command may tend to provide more abstraction than the
low-level library primitives.  Want the inspect-change-inspect cycle to
be fairly intuitive.  I think be wary of abstracting the tool interface
too much, i.e. "make beautiful clock" and loose relationship to the real
hardware.

The command status output should be close to the hardware.  Thus the
change operation should also speak in the same terms, so it is more
intuitive how to specify the new value.  Unspecified values are not changed
and remain as last read.

Should the tool provide all controls?
Probably not, to keep the interface smaller and more user manageable.
But could provide advanced options for more display output.
Idea is keep the simple things simple, and let the lesser needed things
be harder to do.
Crude direct access to the full control register in hex might be a good
way to "do anything", and provide validated options for the common things.
This is much like the library itself.


----------------------------------------------------------------------------
## rgpio Command
----------------------------------------------------------------------------

This is a utility command based on the library.

usage:  rgpio [common_opts..] [feature] [options..]
  feature:
    io              IO pins
    clock           GpClock generators
    ...
  common options:
    --help
    --verbose
    --status        show status, default
    --dev=m|g|f     device file type
    --ro            read-only

  io              IO pins
    format:
      -c,--column     show one bit per line	--col
  ?   -w,--word       show horizontal in word format
      --hex           word format hexadecimal
      --bin           word format binary
    selection:
      --w0            register word 0
      --w1            register word 1
      --reg=R         register to access, R= byte offset or enum
      --bit=P         gpio bit number to access
    modify:  (need all)
      --reg=R         register to access, R= byte offset or enum
      --value=0x00    bit value, 32-bits
      --mask=0xff     mask select bits to change, 32-bits

  clock            GpClock generators
	--set
	--mash=N	enum
	--flip=0
	--enable=0
	--source=N	enum
	--divi=N
	--divf=N
	--div=N.N

Major operations:
    1) Show configuration values.
	Read-only.  Show lots of data, multiple registers together.
    2) Change configuration.
	Modify, focus on single register or Fsel register set.

    Some things get very complex.  Probably better to keep the tool
    simple and reliable, and let the user write code for complex things.

    Tool intended mostly as a viewer of status, and able to make reliable
    focused changes.  NOT to change many things in one call.
    Even the bit list might be too much?


Output format ideas:

IO pins
-------
  --bit --w0
			   3           2            1           0
    bit                   1098 7654 3210 9876 5432 1098 7654 3210

    Fsel                . .... iiii iiii iiii iiii iiii ooii iiii
    PinLevel            . 0000 0000 0000 0000 0000 0000 0000 0000
    EventStatus         . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectRising        . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectFalling       . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectHigh          . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectLow           . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectAsyncRising   . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectAsyncFalling  . 0000 0000 0000 0000 0000 0000 0000 0000

  --hex --w0
    Fsel                rw  .... iiii oooo iiii iiii iiii ooii iiii
    Fsel                rw  0xiioiii?i
    PinLevel            r-  0x00000000
    EventStatus         rw  0x00000000
    DetectRising        rw  0x00000000
    DetectFalling       rw  0x00000000
    DetectHigh          rw  0x00000000
    DetectLow           rw  0x00000000
    DetectAsyncRising   rw  0x00000000
    DetectAsyncFalling  rw  0x00000000

  --column
    bit pin  Fsel  lev  ES dR dF dH dL daR daF
     2   5   In    0    0
     3   6   Out   0    0
     4   7   Alt0  0    0
    14  27   Alt5  0    0
    ...

    Examples:
	rgpio io --reg=rgEventStatus_w0 --value=0xffffffff --mask=0x00000004

	rgpio io --reg=Fsel_w0  --mode=i --mask=0x00000004
		# synthetic enum not a good idea

	rgpio io --Fsel_w0      --mode=i --mask=0x00000ff0
		# set by mask

	rgpio io --fsel=o --bit=4,5,7,21
	rgpio io --mode=o --bit=4,5,7,21
		# set by bits


    Pullup is not part of normal output, since it cannot be read.
    Pullup might be a seperate feature.

    Splitting out sub-features might help clarify operation of tool.
    Nice to see all registers together in a read-only status.
    Setting values probably want to focus on single registers.

    --bit=P,P,..  Bit list to focus on useful bits.
    Probably NOT modify by header pin number (too risky).

    Fsel --column output could also decode the AltN mode for each pin.
	A nice user aid.  Is static data.

    Pin number on header depends on model of RPi or Compute Module.


----------------------------------------------------------------------------
## Error Handling
----------------------------------------------------------------------------

Exceptions:
    Exceptions are intended only for error handling.
    Library functions use exceptions as a way to get an error condition
    to a level where the program can report it thru the proper channels.

    Exceptions in libraries are NOT intended as a mechanism to test for
    a capability.  There are many possible exceptions, and they are not
    specific enough, and their meaning may change.

    We are using the C++ library <stdexcpt> to classify and throw exceptions.

Error Reporting:
    Is the process of getting an error message to the user.
    Most programs will simply write it to stderr.

    A global class is used to report an error message, and to set a flag
    that an error has occured.  The flag can be later used to see if
    any error has occured, e.g. for setting program exit code.

Debug:
    Some classes will have a Debug attribute that can be set to trace
    function execution on stderr.  It is intended as a simple way for a
    user to see and verify some internal behavior.  The actual trace
    output may change.


----------------------------------------------------------------------------
## IO Address Map
----------------------------------------------------------------------------

Addresses:
    The peripheral addresses specified in the BCM document are bus addresses.
    (1.2.4 p.6)

    Addresses are byte addresses, and word (4-byte) aligned.
    Read/Write to periperal address are 32-bits (word size).
    Not sure what happens with a non-word aligned address, or a byte-size
    load/store.

    C address pointers could be:
 >  A) Word address
	uint32_t	*ptr;
	+ Alignment handled by compiler (i.e. is implied).
	+ Seems to be used by wiringPi and bcm2835 libraries.
	- BCM documentation address need to be divided by 4.

    B) Byte address
	uint8_t		*ptr;
	+ Matches BCM documentation.
	- Possible alignment error.
	-- Dereference pointer is a byte access, NOT what we want.

    Use "volatile uint32_t" for register address pointers to be specific
    about word size.  (Also used by wiringPi and bcm2835 libraries.)


----------------------------------------------------------------------------
## Naming of code objects.
----------------------------------------------------------------------------

Enum:
    An enum name is a reserved word within its scope.
    Enumerators defined in a class are in the scope of that class.

    We choose:
    1) Put enums in a class to give the name context.
    2) Name enums with a lower case prefix to help group and make unique.
    [OA named their enums with prefix "oac".]
    If the enum should have limited scope, put it in the class it is used
    with.

----------------------------------------------------------------------------
## Feature Objects - common attributes.
----------------------------------------------------------------------------

Accessor functions get and put values into the object.
Action methods apply the object to the IO registers.

C++ would allow both get_() and put_() functions to have the same names,
since they are distinguished by different arguments.  This does not seem
very helpful to the user, as both functions still need to be declared.
Also a single function name seems awkward to have two different meanings.
Thus use two seperate names to make better clarity for the user.

All BCM2835 registers are 32-bits, with values stored in uint32_t.

Field values passed in accessor functions are also uint32_t, so no bits
are lost in the common conversion from int.
Possibly use int32_t, so negative values could be passed as some kind of
flag - e.g. -1 could mean set to default.

Exceptions:
    Throw an error object containing an error message.
    This would be most useful where continuing with some fallback condition
    is not a good idea.

Error handling:
    Some errors are better to proceed with a fallback condition, but want
    to alert the user that this has happend.  This is where calling global
    (or per-class, or per-object) error message function is good.  It would
    deliver a message on stderr, and set a flag that could be checked at
    program termination to set a non-zero exit code.

    I have used this method a lot in Perl programs, and found that detailed
    error tracking per object or per class is seldom needed.  Most valuable
    is a global error flag for reporting at program termination.
    Especially for utility type tools.
    Now a gui type tool that persists over many operations and needs to
    recover objects after an error would benifit from per-object tracking.

GpioBase address:
    Each Feature object can contain its own copy of the GpioBase address.
    The address allows the object to access the physical IO registers.
    A single process will generally have only one map of the GPIO address
    space, so all addresses will be the same.

    Methods to access a GpioBase address:
 >  A) Copy of GpioBase address.
	+ No dependance on another object.
	- No object to query further information.
    B) Reference to a common GpioBase object.
	+ Full access to the object.
	- A bit more indirection to get the actual register address.
	- Dependance on another object.
    C) Pointer to a global value.
	+ Can check for null before accessing.
	- Not sure how to get desired effect when GpioBase object is destroyed.

    Methods to know "BCM2835 ARM Peripherals" address:
 >  A) Each feature object knows its BCM address.
	x.init_io( rgAddrMap )
	The feature knows how to use an rgAddrMap object.
	+ Nicely self contained.
	- Dependency on rgAddrMap object.
	+ Testing would use a mock rgAddrMap.
    B) User tells feature what BCM address to use.
        x.init_addr( bcm.get_mem_block( addr ) )
	+ Give user control.
	-- User has to know the correct address.
	- More complex use.
	+ May help testing.

    Each feature object knows what its "BCM2835 ARM Peripherals" documented
    address is.  We want the feature object to request the appropriate
    address block from the rgAddrMap object.
	x.init_io()
    OR tell the user what the address is so it can be requeste externally.
        addr = x.get_bcm_addr()
        x.init_addr( bcm.get_mem_block( addr ) )
    OR user tells it what address to use
        x.init_addr( bcm.get_mem_block( addr ) )


    What happens when the address map is revoked?
    We generally don't need to create and destroy multiple GpioBase
    objects.  It is sufficient to create one and keep it for the life of
    the process.  Otherwise it would be nice if the Feature object could
    know if the address map has been destroyed, before accessing it and
    getting a address fault.

    The memory map can only be removed by munmap() system call, after which
    accesses will generate SIGSEGV. 

    ==> Assume the GpioBase address and memory map will persist for the
    life of the process.  This is a good enough assumption.

    Each Feature object knows the offset to its control registers from
    the GpioBase address.


----------------------------------------------------------------------------
## rgAddrMap Object - IO Register Memory Map
----------------------------------------------------------------------------

    Each Feature (Peripheral) has registers in a seperate 4Kbyte block.
    Thus multiple mmap() blocks are needed.

Names
    rgPMap
    rgPerMap
    rgPerpMap
    rgPeripMap
    rgMap
    rgRegBlock
    rgBlocks
    rgMemBlock
    rgMemPage
    rgIoMap
    gGpMap
    rGpMap
    rgpMap
    goMap
    gpMap
    rgRegMap
    rgMemMap

    rgAddrMap
    rgGpClock
    rgSpi
    rgI2c
    rgUart
    rgGpio
    rgPads

There are multiple memory devices:
    1)  /dev/mem	full capability, need root capability
    2)  /dev/gpiomem	only GPIO pins, normal user
    3)  fake_mem	fake on non-RPi

Access mode:
    1)  read/write
    2)  read-only		for read-only intent

    Want simple, obvious ways to specify particular modes.


Object data:
{
    pagemap[]

    int		Dev_fd;		// file descriptor
    
  ? int		mode;		// 0= unset, 1= /dev/mem, 2= /dev/gpiomem,
    					3= fake
    char	*ModeStr;	// user file string, NULL= unset,
				// "/dev/mem", "/dev/gpiomem", "fake_mem"

    int		Prot;		// mmap() prot field,
					default (PROT_READ|PROT_WRITE)

    bool	Debug;		// enable debug trace on stderr
}

Object methods:
    ();		constructor, uninitialized object, for fine config.

    (1);	constructor, full heuristics, ready to use.
    			Select and open dev memory, drop_capabilities.

    get_mem_block( paddr );	// normal request for a register block
			Does the mmap() call.
			paddr = peripheral address in BCM spec

			// set mode and open Dev_fd
    use_dev_mem();
    use_dev_gpiomem();
    use_fake_mem();
 ?  use_heuristic();		// apply heuristic to select dev to open

			// change access mode for next mmap()
    prot_readonly();		// access read-only
    prot_readwrite();		// access read-write

    drop_capabilities();

    close_mfd();		// to release resource, or to change mode


    Possibly defer open of mfd until first get_mem_block() call.

Note:  Must take extreem care to Not use /dev/mem on a non-RPi machine,
    since writing it will likely trash the machine.

Constructor:
    Providing a fully initialize object (Def_fd open, etc) seems nice, but
    is hard to provide the multiple modes.
    Putting a switch in the constructor seems klunky.

    Seems better to provide only a simple constructor, with methods
    to configure it.  This takes more user steps, but is more obvious.

    Maybe add a constructor to do full capability with /dev/mem.

    Maybe a constructor to take a dev file name.  This could help testing.


Heuristic to select mfd mode:
    Not sure I like the heuristic idea.  Benefit is getting partial function
    when user has no permission.  Disadvantage is you don't know what you got,
    and not much comentary.

    if ( not on RPi ) {
	Mode = "fake_mem"
    }
    else if ( not exist /dev/gpiomem ) {
	Mode = "fake_mem"
    }
    else if ( have CAP_DAC_OVERRIDE ) {
	Mode = "/dev/mem"
    }
    else {
	Mode = "/dev/gpiomem"
    }

    Once selected, report errors if cannot open.


----------------------------------------------------------------------------
## GpClock Object
----------------------------------------------------------------------------

See:  p.105-108  6.3 General Purpose GPIO Clocks

The basic operation cycle is:
    x.read_regs();		read IO registers into object

    x.set_Mash( 0 );		modify object config
    x.set_Source( 5 );
    ...
    x.write_regs();		safely update IO registers

There are restrictions on when IO register fields may change in order to
avoid glitches and potential lock-up of the clock generator.
Generally, the clock must be disabled, and have have become not busy
(BUSY=0) before changing any config.

Methods:


Output format:
    ctl[31:0] = 0xfabc0000   control register
    div[31:0] = 0xfabc0000   divider register

    Field         Value     English          R/W Register
    -----------   -----   ----------------   --- ---------
    Clock0.Mash   = 3     integer division   rw  ctl[10:9]
    Clock0.Flip   = 1     not inverted
    Clock0.Busy   = 1     running            r   ctl[7]
    Clock0.Enable = 1     disabled
    Clock0.Source = 15    oscillator
    Clock0.DivI   = 4095                     rw  div[23:12]
    Clock0.DivF   = 4095                     rw  div[11:0]


    The idea is to make the status display almost self-descriptive, to
    reduce the need to continually refer to the manual.

    This output formatting is put in the object to be close to the source.
    Possibly it could be made as a friend object, or derived object.

    Here the English notes seem essential for things like Mash and Source.

    The R/W flags help know if you can change it.
    The Register bit positions help relate to reference doc and 32-bit
    hex value.


Object data:
{
    volatile unsigned	*GpioBase;	// IO base address

    uint32_t		ClkNum;		// Clock number {0,1,2}

    uint32_t		CtlReg;		// Control  register value
    uint32_t		DivReg;		// Divisior register value

}


Methods:

    init_io_addr( rgAddrMap );

    read_regs();
    write_regs();
    raw_write_regs();

    get_Mash();
    put_Mash( bit2 );

    get_Enable();
    put_Enable( bit1 );

    text_status();		All register values.

    get_bcm_address();		Get the "BCM2835 ARM Peripherals" address.
				    Debug.  A simple accessor.


----------------------------------------------------------------------------
## rgIoPin Object
----------------------------------------------------------------------------

This is the GPIO pins and alternate function select.
Features include:
    Function select - In, Out, Alt0 .. Alt5
    Output Set
    Output Clear
    Input read level
    Event Detect Status
    Rising  Edge Detect Enable
    Falling Edge Detect Enable
    High Detect Enable
    Low  Detect Enable
    Async Rising  Edge Detect Enable
    Async Falling Edge Detect Enable
    Pin Pull-up/down  (is write-only?)

See:  p.90-104  6. General Purpose I/O (GPIO)

    There are 54 general-purpose I/O (GPIO) lines, but only the first 28 are
    available on the RPi3.  The compute module can access the first 45.
    Be aware that some may be used for features on the RPi board itself.

    Each register has a low word for bits 31..0, and a high word for
    bits 53..32.  We provide access to both.
    Possibly have a user configurable range check to catch access outside
    of desired bit range.

The basic configuration cycle is:  (maybe not!)
    x.read_regs();		read IO registers into object

    x.set_Func( .. );		modify object config
    x.set_Redge_Den( .. );
    x.set_Fedge_Den( .. );
    x.set_High_Den( .. );
    x.set_Low_Den( .. );
    x.set_ARedge_Den( .. );
    x.set_AFedge_Den( .. );
    ...
    x.write_regs();		update IO registers

	But this is not Atomic.

Data read/write:
    The Read/Set/Clear of pin values is handled by giving direct access to
    the correspondig address.  User code then can read/write as necessary
    to provides the fastest access.

    Possibly also provide accessor functions to operate on a single pin.

Levels of access:
    1) Just provide the register address.  User does all bit twiddling.

    2) Accessor operations for similar registers - e.g. Function Select,
	Detect Enable, Detect Status.
	Operate on small groups of registers.
	Multiple pin operation, since each register is multiple pins.

    3) Single pin operation - modify only one pin of the register.
	Use a pin number instead of a word mask.

    4) Operate on full set of registers - i.e. read/write all registers
	from object data.

    These could mix-and-match, but be aware of both the pin state and object
    state.

Object Data Structure:

    Most registers have one-bit per pin.
	unit32_t	EventStatus

    The Function Select registers have 3-bits per pin.
	Note only FselReg[0..3] are used on RPi.

 >  A) Use register layout directly.
	unit32_t	FselReg[0..5]
	+ Direct access to register values.
	- Must map user abstraction to these.

    B) Abstract into an array of pins.
	uint8_t		FselPin[0..27]
	- Must map into register values for read/write.
	+ Nice user abstraction.

    C) Store both forms.
	+ Conceptually nice.
	- Accessors must update both.

 >  D) Store one form, let the other be Virtual thru accessors.
	+ Probably safest.

    The mapping function needs to be well tested.
    It looks like the mapping can be algorithmic.
    Possibly Fsel is its own object, possibly inherited.

    It is useful to see pin mode with all pins layed out as a 32-bit register.
    Use one char for for each pin, encoded with the pin-mode.  This helps
    see what mask values are needed when doing direct read/write.
    e.g.
	.... iiii iiii iiii oooo 0001 1000 iiii
	    i    = input
	    o    = output
	    0..5 = Alt0 .. Alt5

    get_Fsel()		Return array FselPin[0..27] of mode values.

  x put_Fsel( uint8_t mode[0..27] )	Set mode on all pins.
		Not really useful, unless you read first and modify.

    set_FselMask( uint8_t mode, uint32_t mask )
	mode = the function select mode (3-bit) enum
	mask = one bit per pin, 1= active, 0= not changed
	This should be read-modify-write update.

    get_FselMask( uint8_t mode )	Return mask of pins with that mode.

  ? get_FselReg( reg_number )
  ? put_FselReg( reg_number )

    Mode values:
	1) The raw 3-bit value. { 00, 01, 04,05,06,07,03,02 }
	2) Abstracted Enum.	{ In, Out, Alt0, .. Alt5 }
	3) Character encoding.  { i, o, 0, 1, 2, 3, 4, 5 }

    enum rgFsel_enum {
	fselIN   = 'i',
	fselOUT  = 'o',
	fselAlt0 = '0',
	fselAlt5 = '5',
    }
	Naming these enum with char constants may help in per-bit display.
	Essentially allows using the char constant as the enum value.

    enum rgFsel_enum {
	f_IN   = 00,
	f_OUT  = 01,
	f_Alt0 = 04,
	f_Alt5 = 05,
    }
 >	Naming with raw 3-bit value helps putting the value in the control
	register.

Multiple register update:  Not Atomic.

    Update is by read-modify-write, in order to preserve previous values
    when only some bits change.
    How atomic does this need to be?

    The Function Select registers are shared data.  Multiple independent
    programs each need to set the mode for their pins.  (We assume the pins
    are different in each seperate program.)
    Independently running programs are asynchronous.
    Therefore a synchronization problem exists if register update is not
    atomic.

    In general the synchronization problem cannot be avoided.  The user
    must provide synchronization.  This is OK, and expected.
    [Possibly use mmap() MAP_PRIVATE? - no.  Copy-on-write makes private
    copy and updates are not carried through to the underlying file.]

    Writing only the register modified helps.
    Making the read-modify-write window small helps.
    Thus it might be better to let a single library function call do the
    read-modify-write, instead of seperate calls.
    The set_FselMask() could do this, possibly even isolating to one of
    the 5 registers depending on which mask bits are used.

    I like letting such shared access be done by only a central user utility
    program, run directly by the user.  Then there is no shared resource
    between independent applications.

    Note the Event Dectect registers are shared over all bits, and must
    must be updated by read-modify-write.  Sharing different pins among
    processes seems problematic.

    Consider adding semmaphore capability to help solve synchronization
    problems.  For now, single function read-modify-write seems pretty
    good.

Register update methods:

 >  A) Use a bit mask.
	set_High_Den( mask )
	clr_High_Den( mask )
	+ Operate on all pins at once.
	+ Is close to the programming side.

    B) Use a bit number.  Per-pin update.
	set_High_Den_pin( pin )
	clr_High_Den_pin( pin )
	- Must repeat call for each pin to change.
	- Not as flexible.

    Class data could still be updated in passing.

    It is nice to have one function that reads everything at once, to get
    a snapshot in time.  Just not good to write that to registers, since it
    may have externally changed.

Register access function naming:
    Many config registers are read/write.  Reading all bits is fine.
	read_detect_Rising()

    Writing the register should change only the desired bits according to
    a mask, doing a read/modify/write.  Model as:

    A) Seperate set/clear functions.  1-argument
	set_detect_Rising( mask )
	clr_detect_Rising( mask )
	+ Mimic the set/clr PinLevel registers.
	- Takes two calls to set some bits and clear others.

 >  B) Single function with value and mask.  2-arguments
	put_detect_Rising( value, mask )
	+ One call to both set and clear bits.
	+ Fewer functions.
	- More arguments.

	Maybe name modify_*() to distinguish hardware register access from
	simple data structure access put_*().

Register access enums:
    Use enums for the register offset addresses.
    Defined in the class to provide context.

    Generic functions can use an enum argument.
    Functions named by the register seem clearer in user code.
    Probably provide both.

Register pair naming:
    The Broadcom names are short, but a bit too cryptic (e.g. GPAFEN0).
    The suffix '0' and '1' is not that all obvious out of context.
    Using A/B seems a little better.
    The seperating underscore helps.

    A)  HighDetect0	bits 31..0
	HighDetect1	bits 53..32

    B)  HighDetect	bits 31..0
	HighDetect32	bits 53..32

    C)  HighDetectA	bits 31..0
	HighDetectB	bits 53..32

    D)  HighDetect_A	bits 31..0
	HighDetect_B	bits 53..32

    E)  HighDetect_0	bits 31..0
	HighDetect_1	bits 53..32

 >  F)  HighDetect_w0	bits 31..0
	HighDetect_w1	bits 53..32
	+ Give the 0/1 a little more meaning.

    G)  HighDetect	bits 31..0
	HighDetect_B	bits 53..32
	+ Nice for low bits, no suffix.
	- Is asymetric when both ranges are used.

    Possibly use uint64_t bit values and treat like one register.
	+ Nice abstraction.
	- Not very close to the hardware.
	- Longer words for bit twiddleing.

    Possibly dual functions with a uint32_t mode and uint64_t mode.


Methods:
    (Need high/low register designation)

    read_all_regs()	read all IO registers into object
  x write_all_regs()	write object to IO registers - not recommended.

		read-modify-write update:  (updates object)
    put_FselMask( mode, mask )

    clr_EventStatus( mask )

    put_detect_Rising( value, mask )
    set_detect_Rising( mask )
    clr_detect_Rising( mask )

    set_detect_Falling( mask )
    clr_detect_Falling( mask )

    set_detect_High( mask )
    clr_detect_High( mask )

    set_detect_Low( mask )
    clr_detect_Low( mask )

    set_detect_AsyncRising( mask )
    clr_detect_AsyncRising( mask )

    set_detect_AsyncFalling( mask )
    clr_detect_AsyncFalling( mask )

    set_PullUpDown_mode( mode, mask )

		immediate write:  (no copy in object)
    set_PinLevel( mask )
    clr_PinLevel( mask )

		immediate read:  (also puts copy in object)
    read_FselMask( mode )
    read_EventStatus()
    read_detect_Rising()
    read_detect_Falling()
    ...
    read_PinLevel()		all pins

		object accessor:
    get_FselMask( mode )
    get_EventStatus()
    get_detect_Rising()
    get_detect_Falling()
    ...
    get_PinLevel()		all pins

		register address:
    addr_PinRead()
    addr_PinSet()
    addr_PinClear()
    addr_EventStatus()

		generic functions:  use register identifier enum R
    set_reg( R, mask )
    clr_reg( R, mask )
    read_reg( R )
    get_reg( R )
    addr_reg( R )


Object data:
    (Need high/low register designation)
    All uint32_t.
{
    RegVal[0..]		// register value indexed by IoReg_enum
				Sparse, easy mapping.

		Config registers:
    FselReg[0..5]

    DetRising
    DetFalling
    DetHigh
    DetLow
    DetAsyncRising
    DetAsyncFalling

		Data registers:
    EventStatus
    ReadLevel			PinLevel
}

enum IoReg_enum {		? IoPin_enum,  GpReg_enum
    detect_Rising      = 0x4c,
    detect_Rising32    = 0x50,
    detect_FallingA    = 0x58,
    detect_FallingB    = 0x5c,
    detect_High0       = 0x64,
    detect_High1       = 0x68,
    ...
    rgcEventStatus     = 0x..,
    rgcPinLevel        = 0x..,
    rgcDetectHigh0     = 0x64,
    rgcDetectAsyncFallingA

    rgPinLevel_w0      = 0x..,
    rgPinLevel_w1      = 0x..,

				FuncSel registers for low-level access only.
    rgFsel_r0          = 0x..,
    rgFsel_r1          = 0x..,
    rgFsel_r2          = 0x..,
    rgFsel_r5          = 0x..,

    rgFsel0            = 0x..,

}
    Enum names need to be distict from object data names.
    Data names could be private.

----

    set_Redge_Den( mask )
    clr_Redge_Den( mask )
    set_Fedge_Den( mask )
    clr_Fedge_Den( mask )
    set_High_Den( mask )
    set_Low_Den( mask )
    set_ARedge_Den( mask )
    set_AFedge_Den( mask )
    ...

    set_Den_Redge( mask )
    set_Den_Fedge( mask )
    set_Den_High( mask )
    set_Den_Low( mask )
    set_Den_ARedge( mask )
    set_Den_AFedge( mask )
    ...

    set_Den_Rising( mask )
    set_Den_Falling( mask )
    set_Den_High( mask )
    set_Den_Low( mask )
    set_Den_AsyncRising( mask )
    set_Den_AsyncRising( mask )
    ...

    set_det_Rising( mask )
    set_detect_Rising( mask )
    set_detect_AsyncRising( mask )

Long names with full words seem helpful.

