2017-05-10
		rgpio - Architecture
		---------------------

Raspberry Pi GPIO Tool and Library

References:
-----------
BCM2835 ARM Peripherals
    Ref by RaspberryPi
    /home/var/ref/BCM2835-ARM-Peripherals.pdf
    https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf


----------------------------------------------------------------------------
## Discussion
----------------------------------------------------------------------------

The Library provides a seperate class for each Feature (BCM2845 peripheral).

Possibly each class inherits from a common base class?

The idea is to represent each control register as a unit32_t value and
provide accessors to access each bit field.

Register read/write functions transfer the object register value to/from
the actual processor register.  Some functions may assist with requirements,
e.g. disabling the clock before changing its configuration.

Provide both direct unrestricted access, and methods for common safe operation.

All operations are essentially bit twiddleing.  The value add is:
1)  Abstraction that matches the BCM2835 ARM Peripherals description.
2)  Error checking.
3)  Object oriented interface.  Anti-bugging.

The typical #define bit twiddleing macros provide no error checking.
For configuration access, execution time is generally unimportant.

Using a C union with bit fields was considered, but the ordering and
packing of bit fields is compiler implementation dependent.  Portability
is not important, but having correctness based on experimentation is not
a good idea.  Thus use shift and mask methods instead.

The library classes are intended to be close to the hardware.  They are
NOT intended to hide the hardware or to provide a "future proof" interface
that will allow the hardware to evolve underneath.

Note the utility command may tend to provide more abstraction than the
low-level library primitives.  Want the inspect-change-inspect cycle to
be fairly intuitive.  I think be wary of abstracting the tool interface
too much, i.e. "make beautiful clock" and loose relationship to the real
hardware.

The command status output should be close to the hardware.  Thus the
change operation should also speak in the same terms, so it is more
intuitive how to specify the new value.  Unspecified values are not changed
and remain as last read.

Should the tool provide all controls?
Probably not, to keep the interface smaller and more user manageable.
But could provide advanced options for more display output.
Idea is keep the simple things simple, and let the lesser needed things
be harder to do.
Crude direct access to the full control register in hex might be a good
way to "do anything", and provide validated options for the common things.
This is much like the library itself.

Pin/Bit
    The BCM IO space is accessed as 32-bit registers.  The idea is to stay
    close to this software access model, and thus we speak of bit positions.
    Sometimes "bit" and "pin" are used interchangebly, and usually mean "bit".
    Pin is often used to mean an IO pin of the chip, not a pin number.
    Pin could mean an connector pin number on the Raspberry Pi, but we do
    not provide that kind of pin mapping because different hardware may
    have different pin numbers.

----------------------------------------------------------------------------
## rgpio Command
----------------------------------------------------------------------------

This is a utility command based on the library.

usage:  rgpio [common_opts..] [feature] [options..]
  feature:
    io              IO pins
    clock           GpClock generators
    ...
  common options:
    --help
    --verbose
    --status        show status, default
    --dev=m|g|f     device file type
    --ro            read-only

  io              IO pins
    output format:
      -c,--column     show register columns, one bit per line	--col
      --hex           show word format hexadecimal
      --bin           show word format binary
    selection:
      --w0            register word 0
      --w1            register word 1
      --reg=R         register to access, enum or byte offset
      --bit=N         gpio bit number to access
    observe:
      --read          show register values
    modify:  --reg
      --value=0x00    bit value, 32-bits
      --mask=0xff     mask select bits to change, 32-bits
      --set=0xff      set bits
      --clr=0xff      clear bits
    modify:  --bit
      --fsel=F        function select - In, Out, Alt0 .. Alt5	--mode

  clock            GpClock generators
	--set
	--mash=N	enum
	--flip=0
	--enable=0
	--source=N	enum
	--divi=N
	--divf=N
	--div=N.N

Major operations:
    1) Show configuration values.
	Read-only.  Show lots of data, multiple registers together.
    2) Change configuration.
	Modify, focus on single register or Fsel register set.

    Some things get very complex.  Probably better to keep the tool
    simple and reliable, and let the user write code for complex things.

    Tool intended mostly as a viewer of status, and able to make reliable
    focused changes.  NOT to change many things in one call.
    Even the bit list might be too much?


Output format ideas:

IO pins
-------
  --bit --w0
			   3           2            1           0
    bit                   1098 7654 3210 9876 5432 1098 7654 3210

    Fsel                . .... iiii iiii iiii iiii iiii ooii iiii
    PinLevel            . 0000 0000 0000 0000 0000 0000 0000 0000
    EventStatus         . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectRising        . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectFalling       . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectHigh          . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectLow           . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectAsyncRising   . 0000 0000 0000 0000 0000 0000 0000 0000
    DetectAsyncFalling  . 0000 0000 0000 0000 0000 0000 0000 0000

  --hex --w0
    Fsel                rw  .... iiii oooo iiii iiii iiii ooii iiii
    Fsel                rw  0xiioiii?i
    PinLevel            r-  0x00000000
    EventStatus         rw  0x00000000
    DetectRising        rw  0x00000000
    DetectFalling       rw  0x00000000
    DetectHigh          rw  0x00000000
    DetectLow           rw  0x00000000
    DetectAsyncRising   rw  0x00000000
    DetectAsyncFalling  rw  0x00000000

  --column
    bit pin  Fsel  lev  ES dR dF dH dL daR daF
     2   5   In    0    0
     3   6   Out   0    0
     4   7   Alt0  0    0
    14  27   Alt5  0    0
    ...

    Examples:
	rgpio io --reg=rgEventStatus_w0 --value=0xffffffff --mask=0x00000004

	rgpio io --reg=Fsel_w0  --mode=i --mask=0x00000004
		# synthetic enum not a good idea

	rgpio io --Fsel_w0      --mode=i --mask=0x00000ff0
		# set by mask

	rgpio io --fsel=o --bit=4,5,7,21
	rgpio io --mode=o --bit=4,5,7,21
		# set by bits


    Pullup is not part of normal output, since it cannot be read.
    Pullup might be a seperate feature.

    Splitting out sub-features might help clarify operation of tool.
    Nice to see all registers together in a read-only status.
    Setting values probably want to focus on single registers.

    --bit=P,P,..  Bit list to focus on useful bits.
    Probably NOT modify by header pin number (too risky).

    Fsel --column output could also decode the AltN mode for each pin.
	A nice user aid.  Is static data.

    Pin number on header depends on model of RPi or Compute Module.


----------------------------------------------------------------------------
## Error Handling
----------------------------------------------------------------------------

Exceptions:
    Exceptions are intended only for error handling.
    Library functions use exceptions as a way to get an error condition
    to a level where the program can report it thru the proper channels.

    Exceptions in libraries are NOT intended as a mechanism to test for
    a capability.  There are many possible exceptions, and they are not
    specific enough, and their meaning may change.

    We are using the C++ library <stdexcept> to classify and throw exceptions.

Error Reporting:
    Is the process of getting an error message to the user.
    Most programs will simply write it to stderr.

    A global class is used to report an error message, and to set a flag
    that an error has occured.  The flag can be later used to see if
    any error has occured, e.g. for setting program exit code.

Debug:
    Some classes will have a Debug attribute that can be set to trace
    function execution on stderr.  It is intended as a simple way for a
    user to see and verify some internal behavior.  The actual trace
    output may change.


----------------------------------------------------------------------------
## Validate on Raspberry Pi
----------------------------------------------------------------------------

    Device file /dev/mem exists on most Linux machines.
    Want to be sure we are on an RPi before diddling with it.  Fail safe!

See also:  lscpu(1) proc(5)

On my RaspberryPi-3 I get:

    % uname -a
    Linux raspberrypi 4.9.35-v7+ #1014 SMP Fri Jun 30 14:47:43 BST 2017 armv7l GNU/Linux

    % cat /proc/cpuinfo
    ...
  > Hardware        : BCM2835
  > Revision        : a22082
    Serial          : 000000009c13731b

    % lscpu
    Architecture:          armv7l
    Byte Order:            Little Endian
    CPU(s):                4
    On-line CPU(s) list:   0-3
    Thread(s) per core:    1
    Core(s) per socket:    4
    Socket(s):             1
    Model name:            ARMv7 Processor rev 4 (v7l)
    CPU max MHz:           1200.0000
    CPU min MHz:           600.0000

    The 'uname --nodename' can be most anything, e.g. 'raspberrypi', and
    is not useful here.

    The 'uname --machine' as "armv7l" could be helpful, but the processor
    architecture is not definitive of the hardware.

    The cpuinfo "Hardware : BCM2835" looks most meaningfull.  It also matches
    the "BCM2835 ARM Peripherals" documentation title.

    WiringPi decodes the cpuinfo "Revision : a22082" field.

  > Existance of /dev/gpiomem seems like a reasonable descriminator, but
    still is no guarantee.


----------------------------------------------------------------------------
## IO Address Map
----------------------------------------------------------------------------

Addresses:
    The peripheral addresses specified in the BCM document are bus addresses.
    (1.2.4 p.6)

    Addresses are byte addresses, and word (4-byte) aligned.
    Read/Write to periperal address are 32-bits (word size).
    Not sure what happens with a non-word aligned address, or a byte-size
    load/store.

    C address pointers could be:
 >  A) Word address
	uint32_t	*ptr;
	+ Alignment handled by compiler (i.e. is implied).
	+ Seems to be used by wiringPi and bcm2835 libraries.
	- BCM documentation address need to be divided by 4.

    B) Byte address
	uint8_t		*ptr;
	+ Matches BCM documentation.
	- Possible alignment error.
	-- Dereference pointer is a byte access, NOT what we want.

    Use "volatile uint32_t" for register address pointers to be specific
    about word size.  (Also used by wiringPi and bcm2835 libraries.)


----------------------------------------------------------------------------
## Naming of code objects.
----------------------------------------------------------------------------

Enum:
    An enum name is a reserved word within its scope.
    Enumerators defined in a class are in the scope of that class.

    We choose:
    1) Put enums in a class to give the name context.
    2) Name enums with a lower case prefix to help group and make unique.
    [OA named their enums with prefix "oac".]
    If the enum should have limited scope, put it in the class it is used
    with.

----------------------------------------------------------------------------
## Feature Objects - common attributes.
----------------------------------------------------------------------------

Accessor functions get and put values into the object.
Action methods apply the object to the IO registers.

C++ would allow both get_() and put_() functions to have the same names,
since they are distinguished by different arguments.  This does not seem
very helpful to the user, as both functions still need to be declared.
Also a single function name seems awkward to have two different meanings.
Thus use two seperate names to make better clarity for the user.

All BCM2835 registers are 32-bits, with values stored in uint32_t.

Field values passed in accessor functions are also uint32_t, so no bits
are lost in the common conversion from int.
Possibly use int32_t, so negative values could be passed as some kind of
flag - e.g. -1 could mean set to default.

Object data:
    Feature objects could store a copy of register data.
    The idea is to provide a place to collect and organize the data when
    relationships between register values is important.  For example, the
    whole set of registers could be read at one point in time, and then
    individual accessor functions could extract and interpret data fields.

    Not all object methods would update this cached copy, especially those
    providing direct access with low execution overhead.

    Keep in mind that other parallel processes may update register values,
    and that accessing a group of registers is not atomic.

Exceptions:
    Throw an error object containing an error message.
    This would be most useful where continuing with some fallback condition
    is not a good idea.

Error handling:
    Some errors are better to proceed with a fallback condition, but want
    to alert the user that this has happend.  This is where calling global
    (or per-class, or per-object) error message function is good.  It would
    deliver a message on stderr, and set a flag that could be checked at
    program termination to set a non-zero exit code.

    I have used this method a lot in Perl programs, and found that detailed
    error tracking per object or per class is seldom needed.  Most valuable
    is a global error flag for reporting at program termination.
    Especially for utility type tools.
    Now a gui type tool that persists over many operations and needs to
    recover objects after an error would benifit from per-object tracking.

GpioBase address:
    Each Feature object can contain its own copy of the GpioBase address.
    The address allows the object to access the physical IO registers.
    A single process will generally have only one map of the GPIO address
    space, so all addresses will be the same.

    Methods to access a GpioBase address:
    [This is the user process space full address for each feature.]
 >  A) Copy of GpioBase address.
	+ Keep only what is actually used.
	+ No dependance on another object.  [Not true if the object knows
	    how to use rgAddrMap.]
	- No object to query further information.
    B) Reference to a common GpioBase object.
	+ Full access to the object.
	- A bit more indirection to get the actual register address.
	- Dependance on another object.
    C) Pointer to a global value.
	+ Can check for null before accessing.
	- Not sure how to get desired effect when GpioBase object is destroyed.

    Methods to know "BCM2835 ARM Peripherals" address:
    [This is the documented full register address, grouped together by
    feature.  It needs mapping to the user process full address.]
 >  A) Each feature object knows its BCM address.
	x.init_io( rgAddrMap )
	The feature knows how to use an rgAddrMap object.
	+ Nicely self contained.
	- Dependency on rgAddrMap object.
	+ Testing would use a mock rgAddrMap.
    B) User tells feature what BCM address to use.
        x.init_addr( bcm.get_mem_block( addr ) )
	+ Give user control.
	-- User has to know the correct address.
	- More complex use.
	+ May help testing.

  > Each feature object knows what its "BCM2835 ARM Peripherals" documented
    address is.  We want the feature object to request the appropriate
    address block from the rgAddrMap object.

    What happens when the address map is revoked?
    We generally don't need to create and destroy multiple GpioBase
    objects.  It is sufficient to create one and keep it for the life of
    the process.  Otherwise it would be nice if the Feature object could
    know if the address map has been destroyed, before accessing it and
    getting a address fault.

    The memory map can only be removed by munmap() system call, after which
    accesses will generate SIGSEGV. 

    ==> Assume the GpioBase address and memory map will persist for the
    life of the process.  This is a good enough assumption.

    Each Feature object knows the offset to its control registers from
    the GpioBase address.

Base Address Checking:
    The object can be constructed without setting the base address.
    A seperate init_addr( rgAddrMap ) function can then be applied.

    A problem is the object may not be completely initialized before
    the first register access.

    A) Each access checks initialization.
	+ Defers initialzation to sometime after construction.
	- Each access must do the check.
	- Or risk bad address, e.g. *(GpioBase+reg).
	+ May help in development.

  > B) Constructor does initialization with a given rgAddrMap.
	+ Now the object is guareanteed initialized.
	+ Helps the user and makes one less step.
	+ Can still provied uninit constructor for development.

Offset Address Range Checking:
    Feature addresses should all fall within the feature memory block,
    which is generally one memory page in size.  Register access should not
    be outside this range.  Ways to ensure this:

    A) Accessor functions only accept enums that are guaranteed to be
	within the feature memory block.
	+ The accessor and enum is the guarantee, no overhead.
	- Must keep enum address range clean - good practice anyway.

    B) Accessor functions provide a range check.
	e.g.  require  ((offset && 0xfffff000) == 0)
	+ Provide extra coverage where needed.
	- Overhead on low latency functions.

    Some libraries use #define instead of enum, and thus are not type safe -
    any integer can be substituted.  We want to do better.

----------------------------------------------------------------------------
## rgAddrMap Object - IO Register Memory Map
----------------------------------------------------------------------------

    Each Feature (Peripheral) has registers in a seperate 4Kbyte block.
    Thus multiple mmap() blocks are needed.

Possible class names:
    rgPMap
    rgPerMap
    rgPerpMap
    rgPeripMap
    rgMap
    rgRegBlock
    rgBlocks
    rgMemBlock
    rgMemPage
    rgIoMap
    gGpMap
    rGpMap
    rgpMap
    goMap
    gpMap
    rgRegMap
    rgMemMap

  > rgAddrMap
    rgGpClock
    rgSpi
    rgI2c
    rgUart
    rgGpio
    rgPads

There are multiple memory devices:
    1)  /dev/mem	full capability, need root capability
    2)  /dev/gpiomem	only GPIO pins, normal user
    3)  fake_mem	fake on non-RPi

Access mode:
    1)  read/write
    2)  read-only		for read-only intent

    Want simple, obvious ways to specify particular modes.
    Want to avoid user mistakes in device name.
    Want to allow testing.

Specifying memory device:
    A) Seperate functions for each device.
	+ User cannot get wrong device file name.
	- Function per device file.
    B) open_dev_file( "/dev/mem" )
	+ Very clear what file is opened.
	+ User can specify alternate files.
	- Rely on user not supplying a wrong name.
  > C) Do both.

Object data:
{
    pagemap[]

    int		Dev_fd;		// file descriptor
    
  ? int		mode;		// 0= unset, 1= /dev/mem, 2= /dev/gpiomem,
    					3= fake
    char	*ModeStr;	// user file string, NULL= unset,
				// "/dev/mem", "/dev/gpiomem", "fake_mem"

    int		Prot;		// mmap() prot field,
					default (PROT_READ|PROT_WRITE)

    bool	Debug;		// enable debug trace on stderr
}

Object methods:
    ();		constructor, uninitialized object, for fine config.

    (1);	constructor, full heuristics, ready to use.
    			Select and open dev memory, drop_capabilities.

    get_mem_block( paddr );	// normal request for a register block
			Does the mmap() call.
			paddr = peripheral address in BCM spec

			// set mode and open Dev_fd
    use_dev_mem();
    use_dev_gpiomem();
    use_fake_mem();
 ?  use_heuristic();		// apply heuristic to select dev to open

			// change access mode for next mmap()
    prot_readonly();		// access read-only
    prot_readwrite();		// access read-write

    drop_capabilities();

    close_mfd();		// to release resource, or to change mode


    Possibly defer open of mfd until first get_mem_block() call.

Note:  Must take extreem care to Not use /dev/mem on a non-RPi machine,
    since writing it will likely trash the machine.

Constructor:
    Providing a fully initialize object (Def_fd open, etc) seems nice, but
    is hard to provide the multiple modes.
    Putting a switch in the constructor seems klunky.

    Seems better to provide only a simple constructor, with methods
    to configure it.  This takes more user steps, but is more obvious.

    Maybe add a constructor to do full capability with /dev/mem.

    Maybe a constructor to take a dev file name.  This could help testing.


Heuristic to select mfd mode:
    Not sure I like the heuristic idea.  Benefit is getting partial function
    when user has no permission.  Disadvantage is you don't know what you got,
    and not much comentary.

    if ( not on RPi ) {
	Mode = "fake_mem"
    }
    else if ( not exist /dev/gpiomem ) {
	Mode = "fake_mem"
    }
    else if ( have CAP_DAC_OVERRIDE ) {
	Mode = "/dev/mem"
    }
    else {
	Mode = "/dev/gpiomem"
    }

    Once selected, report errors if cannot open.


----------------------------------------------------------------------------
## GpClock Object
----------------------------------------------------------------------------

See:  p.105-108  6.3 General Purpose GPIO Clocks

The basic operation cycle is:
    x.read_regs();		read IO registers into object

    x.set_Mash( 0 );		modify object config
    x.set_Source( 5 );
    ...
    x.write_regs();		safely update IO registers

There are restrictions on when IO register fields may change in order to
avoid glitches and potential lock-up of the clock generator.
Generally, the clock must be disabled, and have have become not busy
(BUSY=0) before changing any config.

Methods:


Output format:
    ctl[31:0] = 0xfabc0000   control register
    div[31:0] = 0xfabc0000   divider register

    Field         Value     English          R/W Register
    -----------   -----   ----------------   --- ---------
    Clock0.Mash   = 3     integer division   rw  ctl[10:9]
    Clock0.Flip   = 1     not inverted
    Clock0.Busy   = 1     running            r   ctl[7]
    Clock0.Enable = 1     disabled
    Clock0.Source = 15    oscillator
    Clock0.DivI   = 4095                     rw  div[23:12]
    Clock0.DivF   = 4095                     rw  div[11:0]


    The idea is to make the status display almost self-descriptive, to
    reduce the need to continually refer to the manual.

    This output formatting is put in the object to be close to the source.
    Possibly it could be made as a friend object, or derived object.

    Here the English notes seem essential for things like Mash and Source.

    The R/W flags help know if you can change it.
    The Register bit positions help relate to reference doc and 32-bit
    hex value.


Object data:
{
    volatile unsigned	*GpioBase;	// IO base address

    uint32_t		ClkNum;		// Clock number {0,1,2}

    uint32_t		CtlReg;		// Control  register value
    uint32_t		DivReg;		// Divisior register value

}


Methods:

    init_io_addr( rgAddrMap );

    read_regs();
    write_regs();
    raw_write_regs();

    get_Mash();
    put_Mash( bit2 );

    get_Enable();
    put_Enable( bit1 );

    text_status();		All register values.

    get_bcm_address();		Get the "BCM2835 ARM Peripherals" address.
				    Debug.  A simple accessor.


----------------------------------------------------------------------------
## rgIoPin Object
----------------------------------------------------------------------------

This is the GPIO pins and alternate function select.

See:  p.89-104  6. General Purpose I/O (GPIO)

Features include:
    Function select - In, Out, Alt0 .. Alt5
    Output Set
    Output Clear
    Input read level
    Event Detect Status
    Rising  Edge Detect Enable
    Falling Edge Detect Enable
    High Detect Enable
    Low  Detect Enable
    Async Rising  Edge Detect Enable
    Async Falling Edge Detect Enable
    Pin Pull-up/down  (is write-only?)

    There are 54 general-purpose I/O (GPIO) lines, but only the first 28 are
    available on the RPi3.  The compute module can access the first 45.
    Be aware that some may be used for features on the RPi board itself.

    Each register has a low word for bits 31..0, and a high word for
    bits 53..32.  We provide access to both.
    Possibly have a user configurable range check to catch access outside
    of desired bit range.

The basic configuration cycle is:  (maybe not!)
    x.read_regs();		read IO registers into object

    x.set_Func( .. );		modify object config
    x.set_Redge_Den( .. );
    x.set_Fedge_Den( .. );
    x.set_High_Den( .. );
    x.set_Low_Den( .. );
    x.set_ARedge_Den( .. );
    x.set_AFedge_Den( .. );
    ...
    x.write_regs();		update IO registers

	But this is not Atomic.

Data read/write:
    The Read/Set/Clear of pin values is handled by giving direct access to
    the correspondig address.  User code then can read/write as necessary
    to provides the fastest access.

    Possibly also provide accessor functions to operate on a single pin.

Levels of access:
    1) Just provide the register address.  User does all bit twiddling.

    2) Accessor operations for similar registers - e.g. Function Select,
	Detect Enable, Detect Status.
	Operate on small groups of registers.
	Multiple pin operation, since each register is multiple pins.

    3) Single pin operation - modify only one pin of the register.
	Use a pin number instead of a word mask.

    4) Operate on full set of registers - i.e. read/write all registers
	from object data.

    These could mix-and-match, but be aware of both the pin state and object
    state.

Object Data Structure:

    Most registers have one-bit per pin.
	unit32_t	EventStatus

    The Function Select registers have 3-bits per pin.
	Note only FselReg[0..3] are used on RPi.

 >  A) Use register layout directly.
	unit32_t	FselReg[0..5]
	+ Direct access to register values.
	- Must map user abstraction to these.

    B) Abstract into an array of pins.
	uint8_t		FselPin[0..27]
	- Must map into register values for read/write.
	+ Nice user abstraction.

    C) Store both forms.
	+ Conceptually nice.
	- Accessors must update both.

 >  D) Store one form, let the other be Virtual thru accessors.
	+ Probably safest.

    The mapping function needs to be well tested.
    It looks like the mapping can be algorithmic.
    Possibly Fsel is its own object, possibly inherited.

    It is useful to see pin mode with all pins layed out as a 32-bit register.
    Use one char for for each pin, encoded with the pin-mode.  This helps
    see what mask values are needed when doing direct read/write.
    e.g.
	.... iiii iiii iiii oooo 0001 1000 iiii
	    i    = input
	    o    = output
	    0..5 = Alt0 .. Alt5

    get_Fsel()		Return array FselPin[0..27] of mode values.

  x put_Fsel( uint8_t mode[0..27] )	Set mode on all pins.
		Not really useful, unless you read first and modify.

    set_FselMask( uint8_t mode, uint32_t mask )
	mode = the function select mode (3-bit) enum
	mask = one bit per pin, 1= active, 0= not changed
	This should be read-modify-write update.

    get_FselMask( uint8_t mode )	Return mask of pins with that mode.

  ? get_FselReg( reg_number )
  ? put_FselReg( reg_number )

    Mode values:
	1) The raw 3-bit value. { 00, 01, 04,05,06,07,03,02 }
	2) Abstracted Enum.	{ In, Out, Alt0, .. Alt5 }
	3) Character encoding.  { i, o, 0, 1, 2, 3, 4, 5 }

    enum rgFsel_enum {
	fselIN   = 'i',
	fselOUT  = 'o',
	fselAlt0 = '0',
	fselAlt5 = '5',
    }
	Naming these enum with char constants may help in per-bit display.
	Essentially allows using the char constant as the enum value.

    enum rgFsel_enum {
	f_IN   = 00,
	f_OUT  = 01,
	f_Alt0 = 04,
	f_Alt5 = 05,
    }
 >	Naming with raw 3-bit value helps putting the value in the control
	register.

Object register data as individual members or array:
 >  A) Data members named by register, e.g.
	EventStatus_w0
	ReadLevel_w0
	+ Better identification of registers, not indirect thru enum.
	+ Registers are NOT uniform in their properties.
	- More member names.
	- Access thru enum may be more complex.
	+ Best for individual register accessor functions.

    B) Data array indexed by register Enum, e.g.
	RegVal[0..]		// index by IoReg_enum
	+ Single array, less member names.
	+ Direct mapping access by enum.
	- Sparce arry when enum is the IO register offset.
	- Relies on enum too much.
	- Implies registers are uniform when they are not.

Multiple register update:  Not Atomic.

    Update is by read-modify-write, in order to preserve previous values
    when only some bits change.
    How atomic does this need to be?

    The Function Select registers are shared data.  Multiple independent
    programs each need to set the mode for their pins.  (We assume the pins
    are different in each seperate program.)
    Independently running programs are asynchronous.
    Therefore a synchronization problem exists if register update is not
    atomic.

    In general the synchronization problem cannot be avoided.  The user
    must provide synchronization.  This is OK, and expected.
    [Possibly use mmap() MAP_PRIVATE? - no.  Copy-on-write makes private
    copy and updates are not carried through to the underlying file.]

    Writing only the register modified helps.
    Making the read-modify-write window small helps.
    Thus it might be better to let a single library function call do the
    read-modify-write, instead of seperate calls.
    The set_FselMask() could do this, possibly even isolating to one of
    the 5 registers depending on which mask bits are used.

    I like letting such shared access be done by only a central user utility
    program, run directly by the user.  Then there is no shared resource
    between independent applications.

    Note the Event Dectect registers are shared over all bits, and must
    must be updated by read-modify-write.  Sharing different pins among
    processes seems problematic.

    Consider adding semmaphore capability to help solve synchronization
    problems.  For now, single function read-modify-write seems pretty
    good.

Register update methods:

 >  A) Use a bit mask.
	set_High_Den( mask )
	clr_High_Den( mask )
	+ Operate on all pins at once.
	+ Is close to the programming side.

    B) Use a bit number.  Per-pin update.
	set_High_Den_pin( pin )
	clr_High_Den_pin( pin )
	- Must repeat call for each pin to change.
	- Not as flexible.

    Class data could still be updated in passing.

    It is nice to have one function that reads everything at once, to get
    a snapshot in time.  Just not good to write that to registers, since it
    may have externally changed.

Register access function naming:
    Many config registers are read/write.  Reading all bits is fine.
	read_detect_Rising()

    Writing the register should change only the desired bits according to
    a mask, doing a read/modify/write.  Model as:

    A) Seperate set/clear functions.  1-argument
	set_detect_Rising( mask )
	clr_detect_Rising( mask )
	+ Mimic the set/clr PinLevel registers.
	- Takes two calls to set some bits and clear others.

 >  B) Single function with value and mask.  2-arguments
	put_detect_Rising( value, mask )
	+ One call to both set and clear bits.
	+ Fewer functions.
	- More arguments.

	Maybe name modify_*() to distinguish hardware register access from
	simple data structure access put_*().

Register access enums:  rgIoReg_enum
    Use enums for the register offset addresses.  The enum value is the
    offset value, which can work even with widely seperated values.

    The enums are defined in the class to provide context.  Thus the class
    name is required on the enum name e.g.
	rgIoPin::rgPinLevel_w0
    Seems a bit long, but very specific.

    Enum name strings are provided by a lookup table indexed by rgIoReg_enum.
    The enum values are close enough together to make this practical, and
    have one less mapping.
	static const char*  RegStr[];

    Use accessor functions for enum name string mapping.
	str_IoReg_enum( enum )
	find_IoReg_enum( str )

    String for an enum will throw an exception if the enum is invalid.  This
    is reasonable since the compiler checks the enum.

    Finding enum for a string will throw an exception if enum is not
    found.  In this case we generally have an unknown string and are trying
    to see what enum it represents, if any.

    Decided enum string names should be identical to the enum name, at least
    in the library.  This makes less mappings, and is close to the library
    code (i.e. can cut/paste names between code and external user interface).

    Generic functions can use an enum argument.
    Functions named by the register seem clearer in user code.
    Probably provide both.

find_IoReg_enum() methods for handling "string not found":
    A)  Return a special value, rgIoReg_INVALID.
	+ This is the traditional approach.
	- Requires another enum value.
	- User may not check return value for INVALID.
	- The INVALID enum then becomes a problem for other functions, which
	    then require an additional check.
	- The enum space is no longer uniform.

  > B)  Throw an exception.
	+ Is the C++ way.
	+ Use a local try/catch block if you want evasive action.
	+ Top level try/catch block covers case when you don't care.

Register pair naming:
    The Broadcom names are short, but a bit too cryptic (e.g. GPAFEN0).
    The suffix '0' and '1' is not that all obvious out of context.
    Using A/B seems a little better.
    The seperating underscore helps.

    A)  HighDetect0	bits 31..0
	HighDetect1	bits 53..32

    B)  HighDetect	bits 31..0
	HighDetect32	bits 53..32

    C)  HighDetectA	bits 31..0
	HighDetectB	bits 53..32

    D)  HighDetect_A	bits 31..0
	HighDetect_B	bits 53..32

    E)  HighDetect_0	bits 31..0
	HighDetect_1	bits 53..32

 >  F)  HighDetect_w0	bits 31..0
	HighDetect_w1	bits 53..32
	+ Give the 0/1 a little more meaning.

    G)  HighDetect	bits 31..0
	HighDetect_B	bits 53..32
	+ Nice for low bits, no suffix.
	- Is asymetric when both ranges are used.

    Possibly use uint64_t bit values and treat like one register.
	+ Nice abstraction.
	- Not very close to the hardware.
	- Longer words for bit twiddleing.
	- Implies operating on two registers.

    Possibly dual functions with a uint32_t mode and uint64_t mode.
    Dealing with 64-bit values, which must be decomposed into 32-bit words
    for IO register access, seems too complex.
    ==> Use only 32-bit words, with register pairs.

Accessor Register pair naming:
  > A) Use suffix _w0, _w1:
	read_PinLevel_w0()
	read_PinLevel_w1()
	set_PinLevel_w0( mask )
	set_PinLevel_w1( mask )
	+ Very clear naming.
	- More functions.
	+ Simple functions, easily inline.

    B) Optional argument for word number, defaulting to 0.
	read_PinLevel( 0 )
	read_PinLevel( 1 )
	set_PinLevel( mask )
	set_PinLevel( mask, 1 )
	+ Fewer functions.
	- Optional arguments are not very obvious.
	-- Very confusing with Value or Mask arguments.  Ugh!
	- More complex function, but can still inline.

PinLevel registers:
    The IO pin levels are accessed by 3 registers - read, set, and clear.
    The read register is read-only.  The set/clear registers are write-only.

    A generic modify_reg() read/modify/write function will not work for these
    individual registers.  It might be most useful to abstract this as a
    single PinLevel "virtual register", and not as 3 registers.  But this
    would loose closeness to the hardware.

    Direct PinLevel operations are:
	read_PinLevel_w0()
	set_PinLevel_w0( mask )
	clr_PinLevel_w0( mask )
    These names make operations clear on an abstract PinLevel register, and
    are one-to-one with physical registers.

    Thus "PinLevel" can be an abstraction for the collection of 3 registers.
    We want different names for the abstraction and the actual registers.
    Do NOT put an abstraction in the register enums (rgIoReg_enum), as that
    introduces a non-uniformity.

    PinLevel register enum names:
    A) old idea, initially implemented
      rgPinLevel_w0
      rgOutSet_w0
      rgOutClr_w0
	+ Names similar to the BCM documentation.
	- Not obvious these registers are related.
	- Not clear PinLevel is a read-only register.
 >> B) new, improves on BCM naming
      rgPinRead_w0
      rgPinSet_w0
      rgPinClr_w0
	+ Common prefix groups them together.
	+ More clear which are read and which are write.
	+ Not confused with abstration PinLevl.
	- Not match BCM naming.
    C) hybrid
      rgPinLevel_w0
      rgPinSet_w0
      rgPinClr_w0
	+ PinLevel matches the BCM name.
	- Not clear PinLevel is read-only.
    D) trying to incorporate BCM name in the name
      rgPinLevelRead_w0
      rgPinOutSet_w0
      rgPinOutClr_w0
	- A little longer.
    E) longer
      rgPinlevRead_w0
      rgPinlevSet_w0
      rgPinlevClr_w0

  > Address function names:  correlate with register enum names
	addr_PinRead_w0()
	addr_PinSet_w0()
	addr_PinClr_w0()

    Note that all the GPIO registers are "pins", and we are narrowing the
    meaning of "Pin" to just the pin level registers in this case.

PullUpDown registers:
    These should be abstracted also.

Function Select registers:
    Probably abstract to per-bit manipulation, as whole words is fairly
    complex and not that useful.

    Bit manipulation is provided in a seperate rgFselPin class.
    Whole register access is still provided here.

Generic Register access:
    Provides the same operations for all registers, but some may not be
    appropriate (e.g. write-only registers).

    The generic register methods do not need _w0 or _w1 word access because
    that is contained in the register enum.


Methods:
    (Need high/low register designation)

    read_all_regs()	read all IO registers into object
  x write_all_regs()	write object to IO registers - not recommended.

		read-modify-write update:  (updates object)
    put_FselMask( mode, mask )

    clr_EventStatus( mask )

    put_detect_Rising( value, mask )
    set_detect_Rising( mask )
    clr_detect_Rising( mask )

    set_detect_Falling( mask )
    clr_detect_Falling( mask )

    set_detect_High( mask )
    clr_detect_High( mask )

    set_detect_Low( mask )
    clr_detect_Low( mask )

    set_detect_AsyncRising( mask )
    clr_detect_AsyncRising( mask )

    set_detect_AsyncFalling( mask )
    clr_detect_AsyncFalling( mask )

    set_PullUpDown_mode( mode, mask )

		immediate write:  (no copy in object)
    set_PinLevel( mask )
    clr_PinLevel( mask )

		immediate read:  (also puts copy in object)
    read_FselMask( mode )
    read_EventStatus()
    read_detect_Rising()
    read_detect_Falling()
    ...
    read_PinLevel()		all pins

		object accessor:
    get_FselMask( mode )
    get_EventStatus()
    get_detect_Rising()
    get_detect_Falling()
    ...
    get_PinLevel()		all pins

		register address:
    addr_PinRead_w0()			addr_PinLevel_w0()
    addr_PinSet()
    addr_PinClear()
    addr_EventStatus()

		generic functions:  use register identifier enum R
    addr_reg( R )			address of register
    read_reg( R )			read register
 ?  get_reg( R )			get object value, no read
    modify_reg( R, mask, value )	modify register
    set_reg( R, mask )			set bits in register
    clr_reg( R, mask )			clear bits in register

    Argument order with mask before value for consistancy.  Maybe??

Object data:
    Evolve members to work with object methods.
    All uint32_t.
{
  - RegVal[0..]		// register value indexed by IoReg_enum
				Sparse array, easy mapping.  Not favored.

		Config registers:
    FselReg[0..5]

    DetRising_w0
    DetRising_w1

    DetFalling_w0
    DetFalling_w1

    DetHigh_w0
    DetHigh_w1

    DetLow_w0
    DetLow_w1

    DetAsyncRising_w0
    DetAsyncRising_w1

    DetAsyncFalling_w0
    DetAsyncFalling_w1

		Data registers:
    PinLevel_w0			(ReadLevel)
    PinLevel_w1
	Note the member is read/write, the register is read-only.

    EventStatus_w0
    EventStatus_w1
}

IO register enum name ideas:
enum IoReg_enum {		? IoPin_enum,  GpReg_enum
    detect_Rising      = 0x4c,
    detect_Rising32    = 0x50,
    detect_FallingA    = 0x58,
    detect_FallingB    = 0x5c,
    detect_High0       = 0x64,
    detect_High1       = 0x68,
    ...
    rgcEventStatus     = 0x..,
    rgcPinLevel        = 0x..,
    rgcDetectHigh0     = 0x64,
    rgcDetectAsyncFallingA

    rgPinLevel_w0      = 0x..,
    rgPinLevel_w1      = 0x..,

				FuncSel registers for low-level access only.
    rgFsel_r0          = 0x..,
    rgFsel_r1          = 0x..,
    rgFsel_r2          = 0x..,
    rgFsel_r5          = 0x..,

    rgFsel0            = 0x..,

}
    Enum names need to be distinct from object data names.
    Data names could be private.

----

Accessor method name ideas:

    set_Redge_Den( mask )
    clr_Redge_Den( mask )
    set_Fedge_Den( mask )
    clr_Fedge_Den( mask )
    set_High_Den( mask )
    set_Low_Den( mask )
    set_ARedge_Den( mask )
    set_AFedge_Den( mask )
    ...

    set_Den_Redge( mask )
    set_Den_Fedge( mask )
    set_Den_High( mask )
    set_Den_Low( mask )
    set_Den_ARedge( mask )
    set_Den_AFedge( mask )
    ...

    set_Den_Rising( mask )
    set_Den_Falling( mask )
    set_Den_High( mask )
    set_Den_Low( mask )
    set_Den_AsyncRising( mask )
    set_Den_AsyncRising( mask )
    ...

    set_det_Rising( mask )
    set_detect_Rising( mask )
    set_detect_AsyncRising( mask )

Long names with full words seem helpful.


----------------------------------------------------------------------------
## rgFselPin  Class
----------------------------------------------------------------------------
    Function Select register manipulation class.

    It seemed best to put the Fsel bit manipulation here, along with any
    register storage, and let the rgIoPin class focus on whole word register
    operations.

    It has a pointer to an rgIoPin object to do the actual register access.

Function Select registers:
    Modification of all Fsel pins at once is a bit risky.  An accident could
    affect all pins.  It also aggrevates the synchronization problem with
    other processes.  Thus bit level modification is more useful, and probably
    sufficient.

    Read and save of all Fsel0..Fsel5 registers might be useful.  They would
    be all read at one point in time, and then accessors could get single
    bit values as needed.
    An equivalent could be read all registers and return an array of Fsel
    pin values with no saving.

    Possibly use an Fsel object to hold and manipulate values.
    An Fsel class could be a good container for the various transformation
    methods, things like:  Bit number to register and field position.
    Mode enum translations.

Data members:
    *IoPinX		rgIoPin register object
    FselReg[0..5]	Function Select register values

Methods:
				save state:
    grab_Fsel()				read and save all Fsel0..Fsel5 reg
    get_Fsel_bit( N )			get saved Fsel mode for bit N
  x get_Fsel_array( &A )		get saved Fsel mode for all bits
				direct access (no save):
    read_Fsel_bit( N )			read mode
    modify_Fsel_bit( N, mode )		modify mode
  x read_Fsel_array( &A )		read all fsel bits

    Not sure the array access is that useful.  Probably better to let
    the user do his own loop.


----------------------------------------------------------------------------
## Object Summary
----------------------------------------------------------------------------
    Summary of object data and methods for each class.
    Not intended to be an exact declaration, see *.h files for that.
    Use as a catalog to track implementation.

    key:
	+ = implemented

class rgAddrMap		IO Address Memory Map
{
 +  int		Dev_fd;		device file descriptor
 +  bool	FakeMem;        1= using fake memory, 0= not

 +  char	*ModeStr;	user file string, NULL= unset,
				    "/dev/mem", "/dev/gpiomem", "fake_mem"

		ProtMmap
 +  int		Prot;		mmap() prot field,
				    default (PROT_READ|PROT_WRITE)
		Or pass in get_mem_block()?

 +  bool	Debug;		enable debug trace on stderr

 +  uint32_t	FakeBlock[4096];	simulate address block
    uint32_t	PageMap[]		track mapped blocks

		Constructor:
 +  rgAddrMap()			Construct uninitialized object.
 ?  rgAddrMap( 1 )		Construct and initialize.

 +  bcm2rpi_addr( addr )	Convert BCM offset address to RPi.
 +  text_debug()		Get debug text.

 +  open_dev_file( file )	Open file for mmap().
			    User wrappers:
 +  open_dev_mem()		Open /dev/mem
 +  open_dev_gpiomem()		Open /dev/gpiomem
 +  open_fake_mem()		Open fake memory.

    prot_readonly()
    prot_readwrite()

 +  close_dev()			Close the device file.

 +  get_mem_block( p_addr )	Get peripheral memory block for BCM address.
    drop_capabilities()		Drop root access capability.
 +  is_fake_mem()		TRUE if using fake memory
}


class rgIoPin		GPIO IO Pin control
{
 +  *GpioBase;		base address

		Config registers:
    FselReg[0..5]	function select registers

    DetRising_w0
    DetRising_w1

		Data registers:
    PinLevel_w0
    PinLevel_w1

    EventStatus_w0
    EventStatus_w1

		Enumerations:
  + rgFsel_enum		Function select values, 3-bit octal
  + rgIoReg_enum	Register address offset, word address

		Constructor:
  + rgIoPin()			construct empty object
  + rgIoPin( rgAddrMap )	construct and initialize

  + init_addr( rgAddrMap )	init base address
  + get_base_addr()		get  base address

		Generic register access:  R= rgIoReg_enum
  + addr_reg( R )			address of register
  + read_reg( R )			read register
  + modify_reg( R, mask, value )	modify register
    set_reg( R, mask )			set bits in register
    clr_reg( R, mask )			clear bits in register

		PinLevel register access:
  + addr_PinRead_w0()
  + addr_PinSet_w0()
  + addr_PinClr_w0()

  + read_PinLevel_w0()
  + set_PinLevel_w0( mask )
  + clr_PinLevel_w0( mask )

		Event Status register access:
  + read_EventStatus_w0()

		rgIoReg_enum string conversion:
  + str_IoReg_enum( R )			return cstring
  + find_IoReg_enum( cstring )		return enum

}


class rgFselPin		GPIO Pin Function Select class
{
 +  *IoPinX		rgIoPin register object

    FselReg[0..5]	Function Select register values

		Class Data:
  + ModeStr[]		Fsel mode string names, indexed by rgFsel_enum.

		Enumerations:
  + rgFsel_enum		Function select values, 3-bit octal

		Constructor:
  + rgFselPin( rgIoPin* )		construct and initialize

		Direct access:
  + read_Fsel_bit( N )			read, return rgFsel_enum
  + modify_Fsel_bit( N, mode )  	modify

  + fselreg_bit( N, &pos )		Register field position

		rgFsel_enum string conversion:
  + str_rgFsel_enum( mode )		return cstring
  + find_rgFsel_enum( cstring )		return enum

}

